<!DOCTYPE html>
<html>
<head>
<style type='text/css'>
body { background-color:lightgrey; }
.csfile { background-color:white; padding:1em; margin-top:1em; }
</style>
<title>RSSNewsReader</title>
<body>
<h1>RSSNewsReader</h1>
<dl><dt>Date Created</dt><dd>18:46 22 April 2014</dd>
<dt>Username</dt><dd>Alasdair</dd>
<dt>Machine Name</dt><dd>ALASDAIR_TOSH</dd>
<dt>Full path</dt><dd>C:\Users\Alasdair\SkyDrive\Projects\RSSNewsReader\RSSNewsReader\RSSNewsReader.csproj</dd></dl>
<h2>References</h2>
<ul>
<li>Microsoft.VisualBasic</li>
<li>System</li>
<li>System.Core</li>
<li>System.Xml.Linq</li>
<li>System.Data.DataSetExtensions</li>
<li>Microsoft.CSharp</li>
<li>System.Data</li>
<li>System.Deployment</li>
<li>System.Drawing</li>
<li>System.Windows.Forms</li>
<li>System.Xml</li>
<li>WebbIEActivation</li>
<li>WebbIEUpdater</li>
</ul>
<h2>Contents</h2>
<ul>
<li><a href='#file:///C:/Users/Alasdair/SkyDrive/Projects/RSSNewsReader/RSSNewsReader/RSSNewsReader.csproj'>RSSNewsReader.csproj</a></li>
<li><a href='#clsLibrary.cs'>clsLibrary.cs</a></li>
<li><a href='#clsXML.cs'>clsXML.cs</a></li>
<li><a href='#frmMain.cs'>frmMain.cs</a></li>
<li><a href='#frmMain.designer.cs'>frmMain.designer.cs</a></li>
<li><a href='#ListBoxSounds.cs'>ListBoxSounds.cs</a></li>
<li><a href='#modI18N.cs'>modI18N.cs</a></li>
<li><a href='#Program.cs'>Program.cs</a></li>
<li><a href='#Properties\AssemblyInfo.cs'>Properties\AssemblyInfo.cs</a></li>
<li><a href='#ReadDatabase.cs'>ReadDatabase.cs</a></li>
<li><a href='#RSSFeed.cs'>RSSFeed.cs</a></li>
<li><a href='#RSSItem.cs'>RSSItem.cs</a></li>
<li><a href='#Properties\Resources.Designer.cs'>Properties\Resources.Designer.cs</a></li>
<li><a href='#Properties\Settings.Designer.cs'>Properties\Settings.Designer.cs</a></li>
</ul>
<div class='csfile'>
<h2 id='file:///C:/Users/Alasdair/SkyDrive/Projects/RSSNewsReader/RSSNewsReader/RSSNewsReader.csproj'>RSSNewsReader.csproj</h2>
<pre>

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt;
&lt;PropertyGroup&gt;
&lt;Configuration Condition=" '$(Configuration)' == '' "&gt;Debug
&lt;/Configuration&gt;
&lt;Platform Condition=" '$(Platform)' == '' "&gt;x86
&lt;/Platform&gt;
&lt;ProductVersion&gt;8.0.30703
&lt;/ProductVersion&gt;
&lt;SchemaVersion&gt;2.0
&lt;/SchemaVersion&gt;
&lt;ProjectGuid&gt;{0F339DD7-CD08-4778-90A2-A6805CE473C1}
&lt;/ProjectGuid&gt;
&lt;OutputType&gt;WinExe
&lt;/OutputType&gt;
&lt;AppDesignerFolder&gt;Properties
&lt;/AppDesignerFolder&gt;
&lt;RootNamespace&gt;RSSNewsReader
&lt;/RootNamespace&gt;
&lt;AssemblyName&gt;RSSNewsReader
&lt;/AssemblyName&gt;
&lt;TargetFrameworkVersion&gt;v4.0
&lt;/TargetFrameworkVersion&gt;
&lt;TargetFrameworkProfile&gt;Client
&lt;/TargetFrameworkProfile&gt;
&lt;FileAlignment&gt;512
&lt;/FileAlignment&gt;
&lt;IsWebBootstrapper&gt;true
&lt;/IsWebBootstrapper&gt;
&lt;PublishUrl&gt;publish\
&lt;/PublishUrl&gt;
&lt;Install&gt;true
&lt;/Install&gt;
&lt;InstallFrom&gt;Web
&lt;/InstallFrom&gt;
&lt;UpdateEnabled&gt;false
&lt;/UpdateEnabled&gt;
&lt;UpdateMode&gt;Foreground
&lt;/UpdateMode&gt;
&lt;UpdateInterval&gt;7
&lt;/UpdateInterval&gt;
&lt;UpdateIntervalUnits&gt;Days
&lt;/UpdateIntervalUnits&gt;
&lt;UpdatePeriodically&gt;false
&lt;/UpdatePeriodically&gt;
&lt;UpdateRequired&gt;false
&lt;/UpdateRequired&gt;
&lt;MapFileExtensions&gt;true
&lt;/MapFileExtensions&gt;
&lt;InstallUrl&gt;http://www.webbie.org.uk/rssnewsreader/
&lt;/InstallUrl&gt;
&lt;ApplicationRevision&gt;1
&lt;/ApplicationRevision&gt;
&lt;ApplicationVersion&gt;3.0.0.%2a
&lt;/ApplicationVersion&gt;
&lt;UseApplicationTrust&gt;false
&lt;/UseApplicationTrust&gt;
&lt;PublishWizardCompleted&gt;true
&lt;/PublishWizardCompleted&gt;
&lt;BootstrapperEnabled&gt;true
&lt;/BootstrapperEnabled&gt;
&lt;/PropertyGroup&gt;
&lt;PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' "&gt;
&lt;PlatformTarget&gt;x86
&lt;/PlatformTarget&gt;
&lt;DebugSymbols&gt;true
&lt;/DebugSymbols&gt;
&lt;DebugType&gt;full
&lt;/DebugType&gt;
&lt;Optimize&gt;false
&lt;/Optimize&gt;
&lt;OutputPath&gt;bin\Debug\
&lt;/OutputPath&gt;
&lt;DefineConstants&gt;DEBUG;TRACE
&lt;/DefineConstants&gt;
&lt;ErrorReport&gt;prompt
&lt;/ErrorReport&gt;
&lt;WarningLevel&gt;4
&lt;/WarningLevel&gt;
&lt;/PropertyGroup&gt;
&lt;PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' "&gt;
&lt;PlatformTarget&gt;x86
&lt;/PlatformTarget&gt;
&lt;DebugType&gt;pdbonly
&lt;/DebugType&gt;
&lt;Optimize&gt;true
&lt;/Optimize&gt;
&lt;OutputPath&gt;bin\Release\
&lt;/OutputPath&gt;
&lt;DefineConstants&gt;TRACE
&lt;/DefineConstants&gt;
&lt;ErrorReport&gt;prompt
&lt;/ErrorReport&gt;
&lt;WarningLevel&gt;4
&lt;/WarningLevel&gt;
&lt;/PropertyGroup&gt;
&lt;PropertyGroup&gt;
&lt;ManifestCertificateThumbprint&gt;1996681DDCD3200259D56D818146B0ACBD731D08
&lt;/ManifestCertificateThumbprint&gt;
&lt;/PropertyGroup&gt;
&lt;PropertyGroup&gt;
&lt;ManifestKeyFile&gt;RSSNewsReader_TemporaryKey.pfx
&lt;/ManifestKeyFile&gt;
&lt;/PropertyGroup&gt;
&lt;PropertyGroup&gt;
&lt;GenerateManifests&gt;false
&lt;/GenerateManifests&gt;
&lt;/PropertyGroup&gt;
&lt;PropertyGroup&gt;
&lt;SignManifests&gt;false
&lt;/SignManifests&gt;
&lt;/PropertyGroup&gt;
&lt;PropertyGroup&gt;
&lt;ApplicationIcon&gt;RSSNewsReader.ico
&lt;/ApplicationIcon&gt;
&lt;/PropertyGroup&gt;
&lt;PropertyGroup&gt;
&lt;TargetZone&gt;LocalIntranet
&lt;/TargetZone&gt;
&lt;/PropertyGroup&gt;
&lt;PropertyGroup&gt;
&lt;ApplicationManifest&gt;Properties\app.manifest
&lt;/ApplicationManifest&gt;
&lt;/PropertyGroup&gt;
&lt;ItemGroup&gt;
&lt;Reference Include="Microsoft.VisualBasic" /&gt;
&lt;Reference Include="System" /&gt;
&lt;Reference Include="System.Core" /&gt;
&lt;Reference Include="System.Xml.Linq" /&gt;
&lt;Reference Include="System.Data.DataSetExtensions" /&gt;
&lt;Reference Include="Microsoft.CSharp" /&gt;
&lt;Reference Include="System.Data" /&gt;
&lt;Reference Include="System.Deployment" /&gt;
&lt;Reference Include="System.Drawing" /&gt;
&lt;Reference Include="System.Windows.Forms" /&gt;
&lt;Reference Include="System.Xml" /&gt;
&lt;Reference Include="WebbIEActivation"&gt;
&lt;HintPath&gt;..\..\BBCiPlayerTV\WebbIEActivation\bin\Release\WebbIEActivation.dll
&lt;/HintPath&gt;
&lt;/Reference&gt;
&lt;Reference Include="WebbIEUpdater"&gt;
&lt;HintPath&gt;..\..\BBCiPlayerTV\WebbIEUpdater\bin\Release\WebbIEUpdater.dll
&lt;/HintPath&gt;
&lt;/Reference&gt;
&lt;/ItemGroup&gt;
&lt;ItemGroup&gt;
&lt;Compile Include="clsLibrary.cs" /&gt;
&lt;Compile Include="clsXML.cs" /&gt;
&lt;Compile Include="frmMain.cs"&gt;
&lt;SubType&gt;Form
&lt;/SubType&gt;
&lt;/Compile&gt;
&lt;Compile Include="frmMain.designer.cs"&gt;
&lt;DependentUpon&gt;frmMain.cs
&lt;/DependentUpon&gt;
&lt;/Compile&gt;
&lt;Compile Include="ListBoxSounds.cs" /&gt;
&lt;Compile Include="modI18N.cs" /&gt;
&lt;Compile Include="Program.cs" /&gt;
&lt;Compile Include="Properties\AssemblyInfo.cs" /&gt;
&lt;Compile Include="ReadDatabase.cs" /&gt;
&lt;Compile Include="RSSFeed.cs" /&gt;
&lt;Compile Include="RSSItem.cs" /&gt;
&lt;EmbeddedResource Include="frmMain.resx"&gt;
&lt;DependentUpon&gt;frmMain.cs
&lt;/DependentUpon&gt;
&lt;/EmbeddedResource&gt;
&lt;EmbeddedResource Include="Properties\Resources.resx"&gt;
&lt;Generator&gt;ResXFileCodeGenerator
&lt;/Generator&gt;
&lt;LastGenOutput&gt;Resources.Designer.cs
&lt;/LastGenOutput&gt;
&lt;SubType&gt;Designer
&lt;/SubType&gt;
&lt;/EmbeddedResource&gt;
&lt;Compile Include="Properties\Resources.Designer.cs"&gt;
&lt;AutoGen&gt;True
&lt;/AutoGen&gt;
&lt;DependentUpon&gt;Resources.resx
&lt;/DependentUpon&gt;
&lt;/Compile&gt;
&lt;None Include="app.config" /&gt;
&lt;None Include="default.opml"&gt;
&lt;CopyToOutputDirectory&gt;Always
&lt;/CopyToOutputDirectory&gt;
&lt;SubType&gt;Designer
&lt;/SubType&gt;
&lt;/None&gt;
&lt;None Include="Properties\app.manifest" /&gt;
&lt;None Include="Properties\Settings.settings"&gt;
&lt;Generator&gt;SettingsSingleFileGenerator
&lt;/Generator&gt;
&lt;LastGenOutput&gt;Settings.Designer.cs
&lt;/LastGenOutput&gt;
&lt;/None&gt;
&lt;Compile Include="Properties\Settings.Designer.cs"&gt;
&lt;AutoGen&gt;True
&lt;/AutoGen&gt;
&lt;DependentUpon&gt;Settings.settings
&lt;/DependentUpon&gt;
&lt;DesignTimeSharedInput&gt;True
&lt;/DesignTimeSharedInput&gt;
&lt;/Compile&gt;
&lt;None Include="RSSNewsReader.Help-en.rtf"&gt;
&lt;CopyToOutputDirectory&gt;Always
&lt;/CopyToOutputDirectory&gt;
&lt;/None&gt;
&lt;None Include="RSSNewsReader_TemporaryKey.pfx" /&gt;
&lt;/ItemGroup&gt;
&lt;ItemGroup&gt;
&lt;Content Include="Common.Language.xml"&gt;
&lt;CopyToOutputDirectory&gt;Always
&lt;/CopyToOutputDirectory&gt;
&lt;SubType&gt;Designer
&lt;/SubType&gt;
&lt;/Content&gt;
&lt;Content Include="opmldoc.ico"&gt;
&lt;CopyToOutputDirectory&gt;Always
&lt;/CopyToOutputDirectory&gt;
&lt;/Content&gt;
&lt;Content Include="RSSNewsReader.ico"&gt;
&lt;CopyToOutputDirectory&gt;Always
&lt;/CopyToOutputDirectory&gt;
&lt;/Content&gt;
&lt;Content Include="RSSNewsReader.Language.xml"&gt;
&lt;CopyToOutputDirectory&gt;Always
&lt;/CopyToOutputDirectory&gt;
&lt;/Content&gt;
&lt;/ItemGroup&gt;
&lt;ItemGroup&gt;
&lt;BootstrapperPackage Include=".NETFramework,Version=v4.0,Profile=Client"&gt;
&lt;Visible&gt;False
&lt;/Visible&gt;
&lt;ProductName&gt;Microsoft .NET Framework 4 Client Profile %28x86 and x64%29
&lt;/ProductName&gt;
&lt;Install&gt;true
&lt;/Install&gt;
&lt;/BootstrapperPackage&gt;
&lt;BootstrapperPackage Include="Microsoft.Net.Client.3.5"&gt;
&lt;Visible&gt;False
&lt;/Visible&gt;
&lt;ProductName&gt;.NET Framework 3.5 SP1 Client Profile
&lt;/ProductName&gt;
&lt;Install&gt;false
&lt;/Install&gt;
&lt;/BootstrapperPackage&gt;
&lt;BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1"&gt;
&lt;Visible&gt;False
&lt;/Visible&gt;
&lt;ProductName&gt;.NET Framework 3.5 SP1
&lt;/ProductName&gt;
&lt;Install&gt;false
&lt;/Install&gt;
&lt;/BootstrapperPackage&gt;
&lt;BootstrapperPackage Include="Microsoft.Windows.Installer.3.1"&gt;
&lt;Visible&gt;False
&lt;/Visible&gt;
&lt;ProductName&gt;Windows Installer 3.1
&lt;/ProductName&gt;
&lt;Install&gt;true
&lt;/Install&gt;
&lt;/BootstrapperPackage&gt;
&lt;/ItemGroup&gt;
&lt;Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" /&gt;
&lt;PropertyGroup&gt;
&lt;PostBuildEvent&gt;
&lt;/PostBuildEvent&gt;
&lt;/PropertyGroup&gt;
&lt;!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  
&lt;Target Name="BeforeBuild"&gt;
  
&lt;/Target&gt;
  
&lt;Target Name="AfterBuild"&gt;
  
&lt;/Target&gt;
  --&gt;
&lt;/Project&gt;
</pre>
</div>
<div class='csfile'>
<h2 id='clsLibrary.cs'>clsLibrary.cs</h2>
<pre>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ComponentModel;

namespace RSSNewsReader
{
<span style='color:green'>    /// &lt;summary></span>
<span style='color:green'>    /// Indicates that a feed has a certain number of items read or unread,</span>
<span style='color:green'>    /// and that the UI should update the list.</span>
<span style='color:green'>    /// &lt;/summary></span>
<span style='color:green'>    /// &lt;param name="url">The url of the feed&lt;/param></span>
<span style='color:green'>    /// &lt;param name="count">The number of unread items.&lt;/param></span>
    public delegate void ItemCountUpdatedHandler(string url, int count);

<span style='color:green'>    /// &lt;summary></span>
<span style='color:green'>    /// Indicates that the feed has progressed towards being loaded, and</span>
<span style='color:green'>    /// the UI should update the status bar.</span>
<span style='color:green'>    /// &lt;/summary></span>
<span style='color:green'>    /// &lt;param name="message">&lt;/param></span>
    public delegate void LoadProgressHandler(string message);

<span style='color:green'>    /// &lt;summary></span>
<span style='color:green'>    /// Fires when an RSS feed is successfully loaded, and the</span>
<span style='color:green'>    /// UI should display its contents</span>
<span style='color:green'>    /// &lt;/summary></span>
    public delegate void LoadCompletedHandler();

<span style='color:green'>    /// &lt;summary></span>
<span style='color:green'>    /// Fires when there is a problem loading a feed, and the UI should</span>
<span style='color:green'>    /// tell the user.</span>
<span style='color:green'>    /// &lt;/summary></span>
    public delegate void LoadFailedHandler(string url, clsLibrary.ParseResult parseResult);

<span style='color:green'>    /// &lt;summary></span>
<span style='color:green'>    /// Manages the user's RSS and Atom feeds.</span>
<span style='color:green'>    /// &lt;/summary></span>
    public class clsLibrary
    {
        public enum ParseResult
        {
<span style='color:green'>            /// &lt;summary></span>
<span style='color:green'>            /// The RSS or Atom feed was obtained and parsed correctly.</span>
<span style='color:green'>            /// &lt;/summary></span>
            OK,
<span style='color:green'>            /// &lt;summary></span>
<span style='color:green'>            /// The Microsoft XML library returned an "Invalid Url" error.</span>
<span style='color:green'>            /// &lt;/summary></span>
            InvalidURL,
<span style='color:green'>            /// &lt;summary></span>
<span style='color:green'>            /// This is not an RSS feed, nor an Atom feed. </span>
<span style='color:green'>            /// &lt;/summary></span>
            InvalidDocumentType,
<span style='color:green'>            /// &lt;summary></span>
<span style='color:green'>            /// This is an HTML document, not an RSS or Atom feed.</span>
<span style='color:green'>            /// &lt;/summary></span>
            ThisIsHTMLNotRSSOrAtom,
<span style='color:green'>            /// &lt;summary></span>
<span style='color:green'>            /// We haven't downloaded this RSS feed to the cache and we can't now, but</span>
<span style='color:green'>            /// it might just be that the network is down.</span>
<span style='color:green'>            /// &lt;/summary></span>
            CouldNotGetRightNowMaybeNetwork,
<span style='color:green'>            /// &lt;summary></span>
<span style='color:green'>            /// Some other parsing error, possibly from the Microsoft XML library</span>
<span style='color:green'>            /// &lt;/summary></span>
            UnknownError
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// The index of the feed last checked for its item count to update the UI.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private int _FeedWithUpdatedItemCountIndex;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Additional information to do with the parse result.</span>
<span style='color:green'>        /// &lt;/summary></span>
        public string ParseResultMessage;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Update on progress in loading a feed.</span>
<span style='color:green'>        /// &lt;/summary></span>
        public event LoadProgressHandler LoadProgress;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// This feed didn't load.</span>
<span style='color:green'>        /// &lt;/summary></span>
        public event LoadFailedHandler LoadFailed;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Feed loaded okay.</span>
<span style='color:green'>        /// &lt;/summary></span>
        public event LoadCompletedHandler LoadFinished;

        private enum LibraryState
        {
<span style='color:green'>            /// &lt;summary></span>
<span style='color:green'>            /// Caching things, working away, quite happy.</span>
<span style='color:green'>            /// &lt;/summary></span>
            Quiet,
<span style='color:green'>            /// &lt;summary></span>
<span style='color:green'>            /// Loading a feed from the Internet.</span>
<span style='color:green'>            /// &lt;/summary></span>
            LoadingFeed
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Records which items are deleted/removed.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private ReadDatabase _readDatabase;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// The level of child nodes of the item nodes in an Atom document.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private const int ATOM_ITEM_LEVEL = 2;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// The level of child nodes of the item nodes in an RSS document.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private const int RSS_ITEM_LEVEL = 3;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// The level of child nodes of the document node in an Atom document.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private const int ATOM_DOCUMENT_LEVEL = 1;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// The level of child nodes of the document node in an RSS document.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private const int RSS_DOCUMENT_LEVEL = 2;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// FeedsOPML is an OPML file defining my subscribed feeds.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private System.Xml.XmlDocument _FeedsOPML;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Used for saving feeds.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private string _UserAppDataPath;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// The file we're caching to at present.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private string _CachingFile;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// The currently-selected RSS feed.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private RSSFeed _CurrentFeed;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// The index of the current feed in the _FeedsOPML collection.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private int _CurrentFeedIndex;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// The number of unread items in each feed.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private System.Collections.Hashtable _UnreadCount;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// A feed has a new current number of items.</span>
<span style='color:green'>        /// &lt;/summary></span>
        public event ItemCountUpdatedHandler ItemCountUpdated;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// The url of the feed the user is trying to load. </span>
<span style='color:green'>        /// &lt;/summary></span>
        private string _UrlToGet;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// The path of the cache file to save _UrlToGet to.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private string _FileToGet;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Indicates that the cache update process is running, and shouldn't be started.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private bool _UpdatingCache;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Initialise the library - loads all the subscribed RSS feeds.</span>
<span style='color:green'>        /// &lt;/summary></span>
<span style='color:green'>        /// &lt;param name="programFolder">Path of the directory containing the program executable.&lt;/param></span>
<span style='color:green'>        /// &lt;param name="userAppDataPath">Path of the user's AppData directory.&lt;/param></span>
        public clsLibrary(string programFolder, string userAppDataPath)
        {
            this._UnreadCount = new System.Collections.Hashtable();
            this._FeedsOPML = new System.Xml.XmlDocument();
            this._UserAppDataPath = userAppDataPath;
            this._CurrentFeed = null;
            this._UpdatingCache = false;
<span style='color:green'>            // Do we have an existing library?</span>
            if (System.IO.File.Exists(this.FeedOPMLFilePath))
            {
<span style='color:green'>                // Yes, load that.</span>
                this._FeedsOPML.Load(this.FeedOPMLFilePath);
            }
            else
            {
<span style='color:green'>                // No, first run. Load the defaults for the program.</span>
                try
                {
                    this.FeedsOPML.Load("http://www.webbie.org.uk/rssnewsreader/default.opml");
                }
                catch
                {
<span style='color:green'>                    // Failed to load latest default feeds from server, use local copy.</span>
                    this.FeedsOPML.Load(programFolder + "\\default.opml");
                }
            }

<span style='color:green'>            // Load the "read items" file. </span>
            this._readDatabase = new ReadDatabase((new System.IO.DirectoryInfo(userAppDataPath)).Parent.FullName);

<span style='color:green'>            // Start updating</span>
            UpdateFeeds();
        }

        public void UpdateFeeds()
        {
            if (this._UpdatingCache)
            {
<span style='color:green'>                // Already running</span>
            }
            else
            {
<span style='color:green'>                // Start caching in the background.</span>
                this._FeedWithUpdatedItemCountIndex = 0;
                this._UpdatingCache = true;
                CacheFeeds();
            }
        }

        void backgroundWebClient_DownloadFileCompleted(object sender, AsyncCompletedEventArgs e)
        {
<span style='color:green'>            // OK, got a feed. Now need to parse it to find items.</span>
            BackgroundWorker bw = new BackgroundWorker();
            bw.DoWork += bwCaching_DoWork;
            bw.RunWorkerAsync();
        }

        void bwCaching_DoWork(object sender, DoWorkEventArgs e)
        {
            RSSFeed feed;
            if (ParseFeed(this._CachingFile, out feed, null, false))
            {
<span style='color:green'>                // Loaded okay!</span>
                if (this._UnreadCount.ContainsKey(feed.url))
                {
                    this._UnreadCount[feed.url] = feed.UnreadItems.Count;
                }
                else
                {
                    this._UnreadCount.Add(feed.url, feed.UnreadItems.Count);
                }
<span style='color:green'>                // Raise the event</span>
                if (ItemCountUpdated != null)
                {
                    ItemCountUpdated(feed.url, feed.UnreadItems.Count);
                }
            }

<span style='color:green'>            // Go on to the next one.</span>
            CacheFeeds(); 
        }
        
        public System.Xml.XmlDocument FeedsOPML
        {
            get
            {
                return this._FeedsOPML;
            }
        }

        private string FeedOPMLFilePath
        {
            get
            {
                return (new System.IO.DirectoryInfo(this._UserAppDataPath)).Parent.FullName + "\\feeds.opml";
            }
        }

        public void ExportFeedOPML(string path)
        {
            this._FeedsOPML.Save(path);
        }

        public void Save()
        {
            ExportFeedOPML(this.FeedOPMLFilePath);
<span style='color:green'>            // Save any read/hidden items.</span>
            this._readDatabase.WriteItems(this._CurrentFeed);
<span style='color:green'>            // Save what's read</span>
            this._readDatabase.Save();
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Creates an outline node in the feed document, populates it with</span>
<span style='color:green'>        /// the values provided, adds it, sorts the document, and updates the</span>
<span style='color:green'>        /// display of feeds. </span>
<span style='color:green'>        /// &lt;/summary></span>
<span style='color:green'>        /// &lt;param name="url">The actual Atom or RSS file.&lt;/param></span>
<span style='color:green'>        /// &lt;param name="title">The human-readable title/name&lt;/param></span>
<span style='color:green'>        /// &lt;param name="websiteUrl">The URL of the website that "owns" this feed.&lt;/param></span>
        public void AddFeed(string xmlUrl, string title, string websiteUrl)
        {
<span style='color:green'>            //if (title.Length == 0)</span>
<span style='color:green'>            //{</span>
<span style='color:green'>            //    throw new ArgumentException("Missing title attribute for new feed");</span>
<span style='color:green'>            //}</span>
            System.Xml.XmlNode newOutline = this._FeedsOPML.CreateElement("outline");
            System.Xml.XmlAttribute attr;
            attr = this._FeedsOPML.CreateAttribute("title");
            attr.Value = title;
            newOutline.Attributes.SetNamedItem(attr);
            attr = this._FeedsOPML.CreateAttribute("text");
            attr.Value = title;
            newOutline.Attributes.SetNamedItem(attr);
            attr = this._FeedsOPML.CreateAttribute("type");
            attr.Value = "rss";
            newOutline.Attributes.SetNamedItem(attr);
            attr = this._FeedsOPML.CreateAttribute("xmlUrl");
            attr.Value = xmlUrl;
            newOutline.Attributes.SetNamedItem(attr);
            attr = this._FeedsOPML.CreateAttribute("htmlUrl");
            attr.Value = websiteUrl;
            newOutline.Attributes.SetNamedItem(attr);
            this._FeedsOPML.DocumentElement.SelectSingleNode("body").AppendChild(newOutline);
        }

        private string GetCachePath(string url)
        {
            string cachedFilename = SanitizeUrlForFilename(url);
            return new System.IO.DirectoryInfo(this._UserAppDataPath).Parent.FullName + "\\" + cachedFilename;
        }

        private string SanitizeUrlForFilename(string url)
        {
            return url.Replace(":", "_").Replace("?", "_").Replace("/", "_").Replace("\\", "_");
        }

        private void ParseLoadedFeed()
        {
            System.Diagnostics.Debug.Print("Starting parse");
            BackgroundWorker bwCurrent = new BackgroundWorker();
            bwCurrent.DoWork += bwCurrent_DoWork;
            bwCurrent.RunWorkerAsync();
        }

        private void bwCurrent_DoWork(object sender, DoWorkEventArgs e)
        {
            RSSFeed feed;
            System.Xml.XmlNode outlineNode = this._FeedsOPML.DocumentElement.SelectNodes("body/outline")[this._CurrentFeedIndex];
            string url = outlineNode.Attributes.GetNamedItem("xmlUrl").InnerText;
            if (ParseFeed(url, out feed, outlineNode, true))
            {
                this._CurrentFeed = feed;
                ItemCountUpdated(url, feed.UnreadItems.Count);
                LoadFinished();
            }
<span style='color:green'>            // Finished.</span>
            System.Diagnostics.Debug.Print("FINISHED feed load.");
        }

        public void SelectFeed(int feedIndex)
        {
            System.Diagnostics.Debug.Print("Starting SelectFeed(" + feedIndex + ")");
<span style='color:green'>            // What is this feed? Is it a valid index?</span>
            if (feedIndex &lt; 0 || feedIndex > this._FeedsOPML.DocumentElement.SelectNodes("body/outline").Count - 1)
            {
                throw new IndexOutOfRangeException();
            }

            this._CurrentFeedIndex = feedIndex;
            LoadProgress("Opening feed...");

            if (!(this._CurrentFeed == null))
            {
<span style='color:green'>                // First save any read/hidden items.</span>
                _readDatabase.WriteItems(this._CurrentFeed);
            }


<span style='color:green'>            // Get feed details.</span>
            System.Xml.XmlNode outlineNode = this._FeedsOPML.DocumentElement.SelectNodes("body/outline")[this._CurrentFeedIndex];
            string url = outlineNode.Attributes.GetNamedItem("xmlUrl").InnerText;
            string cachedPath = GetCachePath(url);
            System.Diagnostics.Debug.Print("URL: " + Environment.NewLine + "\t" + url);


<span style='color:green'>            // The logic is:</span>
<span style='color:green'>            // * if the feed is missing from the cache, download.</span>
<span style='color:green'>            // * if the feed is present in the cache, and less than fifteen seconds old, serve that.</span>
<span style='color:green'>            // * if the feed is present in the cache, and more than fifteen second old, download it. </span>
<span style='color:green'>            // * if the feed fails to load then serve the cache version.</span>

            bool needToDownload = false;
            if (System.IO.File.Exists(cachedPath))
            {
                System.Diagnostics.Debug.Print("Feed found in cache: " + Environment.NewLine + "\t" + cachedPath);
<span style='color:green'>                // OK, is it &lt; 5 mins old?</span>
                System.IO.FileInfo fi = new System.IO.FileInfo(cachedPath);
                bool olderThanTimeSpan = fi.LastWriteTime &lt; DateTime.Now - new TimeSpan(0, 1, 0);
                if (olderThanTimeSpan)
                {
<span style='color:green'>                    // Need to download afresh. </span>
                    System.Diagnostics.Debug.Print("Feed old, re-download.");
                    needToDownload = true;
                }
            }
            else
            {
                System.Diagnostics.Debug.Print("Feed not found in cache.");
                needToDownload = true;
            }
            if (!needToDownload)
            {
<span style='color:green'>                // OK, easy, used the cached one.</span>
                LoadProgress("Parsing feed...");
                ParseLoadedFeed();
            }
            else
            {
                LoadProgress("Checking feed address is valid...");
<span style='color:green'>                // We haven't got this file. Need to download the file to the cache.</span>
                System.Diagnostics.Debug.Print("Starting feed download process (start by checking URL)");

<span style='color:green'>                // OK, let's go. Start by checking the url.</span>
                BackgroundWorker bwGetFeed = new BackgroundWorker();
                this._UrlToGet = url;
                this._FileToGet = cachedPath;
                bwGetFeed.DoWork += bwGetFeed_DoWork;
                bwGetFeed.RunWorkerAsync();
            }
        }

        void bwGetFeed_DoWork(object sender, DoWorkEventArgs e)
        {
            if (!UrlIsOk(this._UrlToGet))
            {
                System.Diagnostics.Debug.Print("URL failed");
<span style='color:green'>                //"Cannot get the RSS news feed. You might not be online, or the website may be down, or the feed is no longer there.");</span>
<span style='color:green'>                //return ParseResult.CouldNotGetRightNowMaybeNetwork;</span>
                if (System.IO.File.Exists(this._FileToGet))
                {
<span style='color:green'>                    // Serve the cached version of the file.</span>
                    LoadProgress("Parsing feed...");
                    ParseLoadedFeed();
                }
                else
                {
                    LoadFailed(this._UrlToGet, ParseResult.InvalidURL);
                }
                return;
            }
            System.Diagnostics.Debug.Print("URL OK, can download.");

<span style='color:green'>            // OK, looks fine, go on.</span>
            LoadProgress("Getting feed from Internet...");
            System.Net.WebClient wc = new System.Net.WebClient();
            try
            {
                wc.DownloadFileCompleted += wc_DownloadFileCompleted;
                System.Diagnostics.Debug.Print("Starting actual file download from:" + Environment.NewLine + "\t" + this._UrlToGet + Environment.NewLine + "\t" + this._FileToGet);
                wc.DownloadFileAsync(new System.Uri(this._UrlToGet), this._FileToGet);
            }
            catch
            {
<span style='color:green'>                //message = ex.Message;</span>
<span style='color:green'>                //return ParseResult.CouldNotGetRightNowMaybeNetwork;</span>
                LoadFailed(this._UrlToGet, ParseResult.CouldNotGetRightNowMaybeNetwork);
            }
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Feed has been downloaded from the Internet to the local cache, and can now be cached.</span>
<span style='color:green'>        /// &lt;/summary></span>
<span style='color:green'>        /// &lt;param name="sender">&lt;/param></span>
<span style='color:green'>        /// &lt;param name="e">&lt;/param></span>
        void wc_DownloadFileCompleted(object sender, AsyncCompletedEventArgs e)
        {
            System.Diagnostics.Debug.Print("Finished file downloading");
            LoadProgress("Feed downloaded, now parsing...");
<span style='color:green'>            // So it's in the cache now, so I can go ahead and call SelectFeed()...</span>
            SelectFeed(this._CurrentFeedIndex);
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Load the feed from the cache and attempt to parse it.</span>
<span style='color:green'>        /// &lt;/summary></span>
<span style='color:green'>        /// &lt;param name="url">The URL of the feed online (not accessed, it uses the cache)&lt;/param></span>
<span style='color:green'>        /// &lt;param name="feed">Returns the RSSFeed result.&lt;/param></span>
<span style='color:green'>        /// &lt;param name="outlineNode">The OPML node in _FeedsOPML corresponding to this feed.&lt;/param></span>
<span style='color:green'>        /// &lt;param name="selectedFeed">Set to true if this is the feed the user is waiting for, false </span>
<span style='color:green'>        /// otherwise (i.e. false when just caching the feed)&lt;/param></span>
<span style='color:green'>        /// &lt;returns>&lt;/returns></span>
        private bool ParseFeed(string url, out RSSFeed feed, System.Xml.XmlNode outlineNode, bool selectedFeed)
        {
            string cachedPath = GetCachePath(url);
            feed = new RSSFeed(url);
            
<span style='color:green'>            //The MSDN documentation says it's best to create an XmlTextReader through .Create</span>
<span style='color:green'>            //rather than = new XmlTextReader. However, if you do it through new, you get an</span>
<span style='color:green'>            //XmlTextReader that doesn't choke on malformed XML, and if you do it through</span>
<span style='color:green'>            //.Create you choke on malformed XML. So clearly new is better!</span>
            System.Xml.XmlTextReader xtr;
            try
            {
<span style='color:green'>                //xtr = new System.Xml.XmlTextReader(this._CurrentFeed.url);</span>
<span style='color:green'>                //xtr = new System.Xml.XmlTextReader("C:\\Users\\Alasdair\\SkyDrive\\Projects\\RSSParseTest\\RSSParseTest\\Example Atom Feed.xml");</span>
                xtr = new System.Xml.XmlTextReader(cachedPath);
            }
            catch (System.UriFormatException ufe)
            {
                if (selectedFeed)
                {
                    this.ParseResultMessage = "Invalid URL: " + ufe.Message;
                    LoadFailed(url, ParseResult.InvalidURL);
                }
                return false;
            }
            catch (Exception ex)
            {
<span style='color:green'>                // Unknown error - File Not Found, possibly - display and quit.</span>
                if (selectedFeed)
                {
                    this.ParseResultMessage = "Error: " + ex.Message;
                    LoadFailed(url, ParseResult.UnknownError);
                }
                return false;
            }

<span style='color:green'>            // Fix entities. Hmmm, I think the problem is actually malformed input. For example:</span>
<span style='color:green'>            // &lt;title>&lt;![CDATA[The World&#8217;s Simplest HTML5 WYSISYG Inline Editor]]>&lt;/title></span>
<span style='color:green'>            // So leave it for now.</span>

<span style='color:green'>            //xtr.EntityHandling = System.Xml.EntityHandling.ExpandEntities;</span>
<span style='color:green'>            // Now to parse the XML stream into the rendered feed. This is complicated by the</span>
<span style='color:green'>            // fact that many feeds are invalid XML, so we must use an XmlTextReader rather than</span>
<span style='color:green'>            // traversing the DOM.</span>

<span style='color:green'>            // If we run into a problem reading, stop.</span>
            bool readOK = true;

<span style='color:green'>            // States</span>
            string rootNodeName = ""; // The root node: indicates RSS or Atom
            string title = "";
            bool nextTextNodeIsTitle = false;
            string link = "";
            string pubDate = "";
            string contents = "";
            bool nextTextNodeIsLink = false;
            bool nextTextNodeIsUrl = false;
            bool nextTextNodeIsContents = false;
            bool nextTextNodeIsPubDate = false;
            bool isRss = false;
            bool isAtom = false;
            while (!xtr.EOF && readOK)
            {
                try
                {
                    readOK = xtr.Read();
                    if (xtr.NodeType == System.Xml.XmlNodeType.Element)
                    {
                        string elementName = xtr.Name.ToLowerInvariant();
<span style='color:green'>                        // If this is the first node then it is the root node. </span>
<span style='color:green'>                        // Remember the name so that we know what type of document</span>
<span style='color:green'>                        // the user has given us - Atom, RSS, or a web page to</span>
<span style='color:green'>                        // search.</span>
                        if (rootNodeName.Length == 0)
                        {
                            rootNodeName = elementName;
                            if (rootNodeName == "rss")
                            {
                                isRss = true;
                            }
                            else if (rootNodeName == "feed")
                            {
                                isAtom = true;
                            }
                            else if (rootNodeName == "html")
                            {
<span style='color:green'>                                // This is an HTML document.</span>
<span style='color:green'>                                // Can't load HTML files as RSS! (TODO well, we could...)</span>
                                xtr.Close();
                                if (selectedFeed)
                                {
                                    this.ParseResultMessage = "Feed is an HTML file, not RSS or Atom.";
                                    LoadFailed(url, ParseResult.ThisIsHTMLNotRSSOrAtom);
                                }
                                return false;
                            }
                            else
                            {
<span style='color:green'>                                // Alert user not RSS or Atom </span>
<span style='color:green'>                                //message = rootNodeName;</span>
                                xtr.Close();
                                if (selectedFeed)
                                {
                                    this.ParseResultMessage = System.String.Format("Not RSS or Atom (root node is '{0}')", rootNodeName);
                                    LoadFailed(url, ParseResult.InvalidDocumentType);
                                }
                                return false;
<span style='color:green'>                                //return ParseResult.InvalidDocumentType; // TODO provide appropriate message</span>
                            }
                        }
                        else if (isRss || isAtom)
                        {
<span style='color:green'>                            // This is an RSS document.</span>
<span style='color:green'>                            // RSS ("rss") or Atom ("feed")</span>

<span style='color:green'>                            // OK, do we do anything with this node?</span>
                            if (elementName == "item")
                            {
<span style='color:green'>                                // It's a new item, so if we have already got valid information add the item now.</span>
                                if (title.Length > 0 && link.Length > 0)
                                {
                                    RSSItem rssItem = new RSSItem(title, link, feed.url, pubDate, contents);
                                    feed.AddItem(rssItem);
                                }
                                title = "";
                                link = "";
                                pubDate = "";
                                contents = "";
                            }
                            else if (elementName == "title")
                            {
                                if ((xtr.Depth == RSS_ITEM_LEVEL && isRss) || (xtr.Depth == ATOM_ITEM_LEVEL && isAtom))
                                {
<span style='color:green'>                                    // &lt;title> element of an &lt;item> (rss) or &lt;entry> (Atom), not of the document. </span>

                                    if (nextTextNodeIsLink)
                                    {
                                        throw new Exception("State machine error parsing RSS!");
                                    }

                                    nextTextNodeIsTitle = true;
                                }
                            }
                            else if (elementName == "link")
                            {
                                if ((xtr.Depth == RSS_DOCUMENT_LEVEL && isRss) || (xtr.Depth == ATOM_DOCUMENT_LEVEL && isAtom))
                                {
<span style='color:green'>                                    // Check for rel="self", which is the feed itself in Atom. The attribute</span>
<span style='color:green'>                                    // will be missing in RSS, so the test catches that too.</span>
                                    if (xtr.GetAttribute("rel") != "self")
                                    {
<span style='color:green'>                                        // &lt;link> element for the document (not for the &lt;item> or &lt;entry> in the feed)</span>
<span style='color:green'>                                        // Populate/update (missing) webpage url in my OPML file if required.</span>
                                        if (xtr.GetAttribute("href") == "" || xtr.GetAttribute("href") == null)
                                        {
<span style='color:green'>                                            // RSS</span>
                                            nextTextNodeIsUrl = true;
                                        }
                                        else
                                        {
<span style='color:green'>                                            // Atom</span>
                                            if (outlineNode != null)
                                            {
                                                outlineNode.Attributes.GetNamedItem("htmlUrl").Value = xtr.GetAttribute("href");
                                            }
                                        }
                                    }
                                }
                                else if ((xtr.Depth == RSS_ITEM_LEVEL && isRss) || (xtr.Depth == ATOM_ITEM_LEVEL && isAtom))
                                {
<span style='color:green'>                                    // &lt;link> element for an &lt;item> or &lt;entry> (not for the feed as a whole)</span>
                                    if (xtr.GetAttribute("href") == "" || xtr.GetAttribute("href") == null)
                                    {
                                        if (nextTextNodeIsTitle)
                                        {
<span style='color:green'>                                            //TODO throw new Exception("State machine error parsing RSS!");</span>
                                        }

<span style='color:green'>                                        // RSS2</span>
                                        nextTextNodeIsLink = true;
                                    }
                                    else
                                    {
<span style='color:green'>                                        // Atom</span>
                                        if (xtr.GetAttribute("rel") == "alternate")
                                        {
                                            link = xtr.GetAttribute("href");
                                        }
                                    }
                                }
                            }
                            else if (elementName == "dc:date" || elementName == "published" || elementName == "pubDate" || elementName == "pubdate")
                            {
<span style='color:green'>                                // Next node contents is date of publication</span>
                                nextTextNodeIsPubDate = true;
                            }
                            else if (elementName == "content" || elementName == "description")
                            {
                                nextTextNodeIsContents = true;
                            }
                            else
                            {
<span style='color:green'>                                // Element we don't use.</span>
<span style='color:green'>                                //System.Diagnostics.Debug.Print("Element:" + elementName);</span>
                            }
                        }
                    }
                    else if ((xtr.NodeType == System.Xml.XmlNodeType.Text) || (xtr.NodeType == System.Xml.XmlNodeType.CDATA))
                    {
                        if (nextTextNodeIsTitle)
                        {
                            title = xtr.Value;
                            nextTextNodeIsTitle = false;
                        }
                        if (nextTextNodeIsLink)
                        {
                            link = xtr.Value;
                            nextTextNodeIsLink = false;
                        }
                        if (nextTextNodeIsUrl)
                        {
                            if (outlineNode != null)
                            {
                                outlineNode.Attributes.GetNamedItem("htmlUrl").Value = xtr.Value;
                            }
                            nextTextNodeIsUrl = false;
                        }
                        if (nextTextNodeIsContents)
                        {
                            contents = xtr.Value;
                            nextTextNodeIsContents = false;
                        }
                        if (nextTextNodeIsPubDate)
                        {
                            pubDate = xtr.Value;
                            nextTextNodeIsPubDate = false;
                        }
                    }
                }
                catch (System.Net.WebException wexc)
                {
                    if (selectedFeed)
                    {
                        this.ParseResultMessage = wexc.Message;
                        LoadFailed(url, ParseResult.CouldNotGetRightNowMaybeNetwork); //"Network error: " + wexc.Message); 
                    }
<span style='color:green'>                    // Get out.</span>
                    readOK = false;
                    return false;
                }
                catch
                {
<span style='color:green'>                    //Parsing error from the web page or XML = very common, carry on going</span>
<span style='color:green'>                    //until we find something useful.</span>
                }
            }
            xtr.Close();
            if (selectedFeed)
            {
                LoadProgress("Loaded feed...");
            }

<span style='color:green'>            // Do pubdate and contents for the last node.</span>
            if (title.Length > 0 && link.Length > 0)
            {
                RSSItem rssItem = new RSSItem(title, link, feed.url, pubDate, contents);
                feed.AddItem(rssItem);
                title = "";
                link = "";
            }

<span style='color:green'>            // Work out which items are read or not.</span>
            feed.IdentifyReadItems(this._readDatabase);
            return true;
        }


        public RSSFeed currentFeed
        {
            get {
                return this._CurrentFeed;
            }
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Download any feeds to the cache. </span>
<span style='color:green'>        /// &lt;/summary></span>
        private void CacheFeeds()
        {
            System.Xml.XmlNodeList nl = this.FeedsOPML.DocumentElement.SelectNodes("body/outline");
            bool fileDownloadRequired = false;
            string url = "";

<span style='color:green'>            // First look a file that's completely missing OR _FeedWithUpdatedItemCountIndex indicates</span>
<span style='color:green'>            // that we haven't updated it this time through yet.</span>
            string cacheFile = "";
            for (int i = 0; i &lt; nl.Count; i++)
            {
                url = nl[i].Attributes.GetNamedItem("xmlUrl").Value;

                cacheFile = GetCachePath(url);
                if (System.IO.File.Exists(cacheFile))
                {
<span style='color:green'>                    // Exists! Do we still need to download a new one, because we're doing a run through</span>
<span style='color:green'>                    // updating everything?</span>
                    if  (i >= this._FeedWithUpdatedItemCountIndex)
                    {
<span style='color:green'>                        // Yes, we do. Do in background:</span>
                        this._FeedWithUpdatedItemCountIndex = i + 1;
                        fileDownloadRequired = true;
                        this._CachingFile = url;
                        break;
                    }
                }
                else
                {
<span style='color:green'>                    //TODO ptf.AddText("Need to get missing feed");</span>
                    fileDownloadRequired = true;
                    this._CachingFile = url;
                    break;
                }
            }
            if (!fileDownloadRequired)
            {
<span style='color:green'>                // Nope, all got. Look for a file we haven't checked for more than five minutes.</span>
                System.DateTime fiveMinutesAgo = System.DateTime.UtcNow;
                fiveMinutesAgo = fiveMinutesAgo - new System.TimeSpan(0, 5, 0);
                for (int i = 0; i &lt; nl.Count; i++)
                {
                    url = nl[i].Attributes.GetNamedItem("xmlUrl").Value;
                    cacheFile = GetCachePath(url);
                    System.IO.FileInfo fi = new System.IO.FileInfo(cacheFile);
                    if (fi.LastWriteTimeUtc &lt; fiveMinutesAgo)
                    {
                        fileDownloadRequired = true;
                        this._CachingFile = url;
                        break;
                    }
                }
            }
            if (fileDownloadRequired)
            {
<span style='color:green'>                // Found a feed that's completely missing, or old. So download it.</span>
                this._CachingFile = url;
                System.Net.WebClient backgroundWebClient = new System.Net.WebClient();
                backgroundWebClient.DownloadFileCompleted += backgroundWebClient_DownloadFileCompleted;
                backgroundWebClient.DownloadFileAsync(new System.Uri(url), cacheFile);
            }
            else
            {
<span style='color:green'>                // Every feed has been downloaded and parsed in the last five minutes. </span>
                this._UpdatingCache = false;
            }
        }

        public void RemoveAllFeeds()
        {
            this._FeedsOPML.DocumentElement.SelectSingleNode("body").RemoveAll();
            this._readDatabase.ClearAll();
            this._CurrentFeed = null;
        }

        public void RemoveFeed(int index)
        {
            System.Xml.XmlNode outlineNode = this._FeedsOPML.DocumentElement.SelectNodes("body/outline")[index];
            this._readDatabase.RemoveFeed(outlineNode.Attributes.GetNamedItem("xmlUrl").InnerText);
            this._FeedsOPML.DocumentElement.SelectSingleNode("body").RemoveChild(outlineNode);
        }

        private bool UrlIsOk(string url)
        {
            System.Net.HttpWebRequest myHttpWebRequest = (System.Net.HttpWebRequest)System.Net.WebRequest.Create(url);
            myHttpWebRequest.Method = "GET";
<span style='color:green'>            // Assign the response object of 'HttpWebRequest' to a 'HttpWebResponse' variable.</span>
            System.Net.HttpWebResponse myHttpWebResponse;
            try
            {
                myHttpWebResponse = (System.Net.HttpWebResponse)myHttpWebRequest.GetResponse();
            }
            catch // (System.Net.WebException we)
            {
<span style='color:green'>                // Probably not online!</span>
                return false;
            }
            System.Net.HttpStatusCode statusCode = myHttpWebResponse.StatusCode;
            myHttpWebResponse.Close();
            switch (statusCode)
            {
                case System.Net.HttpStatusCode.Accepted:
                    return true;
                case System.Net.HttpStatusCode.Ambiguous:
                    return true;
                case System.Net.HttpStatusCode.Continue:
                    return true;
                case System.Net.HttpStatusCode.Created:
                    return true;
                case System.Net.HttpStatusCode.Found:
                    return true;
                case System.Net.HttpStatusCode.Moved:
                    return true;
<span style='color:green'>                //case System.Net.HttpStatusCode.MovedPermanently:  Same as Moved</span>
<span style='color:green'>                //    return true;</span>
<span style='color:green'>                //case System.Net.HttpStatusCode.MultipleChoices:   Same as Ambiguous</span>
<span style='color:green'>                //    return true;</span>
                case System.Net.HttpStatusCode.NoContent:
                    return true;
                case System.Net.HttpStatusCode.NonAuthoritativeInformation:
                    return true;
                case System.Net.HttpStatusCode.NotModified:
                    return true;
                case System.Net.HttpStatusCode.OK:
                    return true;
                case System.Net.HttpStatusCode.PartialContent:
                    return true;
<span style='color:green'>                //case System.Net.HttpStatusCode.Redirect:    Same as Found</span>
<span style='color:green'>                //    return true;</span>
                case System.Net.HttpStatusCode.RedirectKeepVerb:
                    return true;
                case System.Net.HttpStatusCode.RedirectMethod:
                    return true;
                case System.Net.HttpStatusCode.ResetContent:
                    return true;
<span style='color:green'>                //case System.Net.HttpStatusCode.SeeOther:    Same as RedirectMethod</span>
<span style='color:green'>                //    return true;</span>
                case System.Net.HttpStatusCode.SwitchingProtocols:
                    return true;
<span style='color:green'>                //case System.Net.HttpStatusCode.TemporaryRedirect: Same as RedirectKeepVerb</span>
<span style='color:green'>                //    return true;</span>
                case System.Net.HttpStatusCode.Unused:
                    return true;
                case System.Net.HttpStatusCode.UseProxy:
                    return true;
                default:
                    return false;
            }
        }

        public static string CleanUpXml(string xml)
        {
            return xml.Replace("&#8217;", '\''.ToString()).Replace("&#8211;", "-").Replace("&#8216", '\x8216'.ToString()).Replace("&#8220", '\x8220'.ToString()).Replace("&#8221", '\x8221'.ToString()).Replace("&amp;", "&").Replace("&rsquo;", '\x8217'.ToString()).Replace("&lsquo;", '\x8216'.ToString()).Replace("%lt;", "&lt;").Replace("&gt;", ">").Replace("&quot;", "\"").Replace("&apos;", "'").Replace("&nbsp;", " ").Replace("&#160;", " ");
        }

    }
}
</pre>
</div>
<div class='csfile'>
<h2 id='clsXML.cs'>clsXML.cs</h2>
<pre>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RSSNewsReader
{
    class clsXML
    {
        
    }
}
</pre>
</div>
<div class='csfile'>
<h2 id='frmMain.cs'>frmMain.cs</h2>
<pre>
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;

<span style='color:green'>// RSS News Reader</span>
<span style='color:green'>//  Simple RSS news reading application for screenreader users.</span>
<span style='color:green'>//  3.0.0   Feb     First beta.</span>
<span style='color:green'>//  3.0.1   27 Feb  Fixed news items not opening web page.</span>
<span style='color:green'>//  3.0.2   6 Mar   Loads defaults first time from http://www.webbie.org.uk/rssnewsreader/default.opml</span>
<span style='color:green'>//  3.0.3   2 Apr   Fixed adding RSS feeds, delete item menu item, command line.</span>
<span style='color:green'>//  3.0.4   10 Jun  Made loading feeds fault-tolerant and not hang application. Can now pull feeds from previous versions.</span>
<span style='color:green'>//  3.0.5   13 Jun  Made settings update correctly.</span>
<span style='color:green'>//  3.0.6   25 Jun  2013    Added "Delete All Items" option. Fixed item display. Made showing deleted items work.</span>
<span style='color:green'>//  3.1.0   12 Mar 2014     Made most network and parsing activity asynchronous, so the program no longer hangs the UI</span>
<span style='color:green'>//                          thread.</span>
<span style='color:green'>//                          Item counts now update correctly, and update every five minutes.</span>
<span style='color:green'>//                          Added activation and update mechanisms as DLLs.</span>
<span style='color:green'>//                          New menu option, Delete All - deletes all items.</span>
<span style='color:green'>//</span>
<span style='color:green'>//  Note:</span>
<span style='color:green'>//      Microsoft.VisualBasic.Logging.Log.WriteException(ex, System.Diagnostics.TraceEventType.Error, "Exception in Main(): " + ex.Message);   </span>
<span style='color:green'>//  Future:</span>
<span style='color:green'>//      Add descriptions to titles in list of RSS news stories for more information for users.</span>
<span style='color:green'>//      Use WebbIE to get whole stories.</span>
<span style='color:green'>//      Make a "create newspaper" function. </span>


namespace RSSNewsReader
{
<span style='color:green'>    /// &lt;summary></span>
<span style='color:green'>    /// RSS News Reader</span>
<span style='color:green'>    /// &lt;/summary></span>
    public partial class frmMain : Form
    {

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// The RSS feeds to which we have subscribed.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private clsLibrary _Library;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// For internationalisation.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private I18N _I18N;

        delegate void UpdateFeedStatusDelegate(string url, string message);
        delegate void DisplayStatusMessageDelegate(string message);
        delegate void DisplayItemsDelegate();
        delegate void UpdateItemCountDelegate(string url, int count);

        private DateTime _LastChecked;

        public frmMain()
        {
            InitializeComponent();
        }

        private void exitToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Application.Exit();
        }

        private void CheckForUpdates()
        {
<span style='color:green'>            // Have we checked already today?</span>
            if (Properties.Settings.Default.UpdateCheck != System.DateTime.Now.ToShortDateString())
            {
<span style='color:green'>                // No! Let's do so.</span>
<span style='color:green'>                // First note that we have now checked today.</span>
                Properties.Settings.Default.UpdateCheck = System.DateTime.Now.ToShortDateString();
                Properties.Settings.Default.Save();
                WebbIE.Updater.CheckForUpdates("http://www.webbie.org.uk/rssnewsreader/updates.xml");
            }
        }

        private void frmMain_Load(object sender, EventArgs e)
        {
<span style='color:green'>            // Check for updates</span>
            CheckForUpdates();

<span style='color:green'>            // Activate</span>
            WebbIE.Activation.Activate("RSSNewsReader3");

<span style='color:green'>            // Normal WebbIE I18N code.</span>
            this._I18N = new I18N();
            this._I18N.DoForm(this);

<span style='color:green'>            // Load the user-subscribed list of feeds.</span>
            this._Library = new clsLibrary(Environment.CurrentDirectory, Application.UserAppDataPath);
            this._Library.ItemCountUpdated += _Library_itemCountUpdated;
            this._Library.LoadProgress += _Library_LoadProgress;
            this._Library.LoadFailed += _Library_LoadFailed;
            this._Library.LoadFinished += _Library_LoadFinished;

<span style='color:green'>            // Updating previous versions. Check for feeds.xml. This will be located in:</span>
            string existingFeedFile = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\WebbIE\\AccessibleRSS\\1\\feeds.xml";
            if (System.IO.File.Exists(existingFeedFile))
            {
<span style='color:green'>                // We have an existing feed file. Do we need to import it? Have we already?</span>
                System.IO.FileInfo fi = new System.IO.FileInfo(existingFeedFile);
                if (fi.LastWriteTimeUtc > RSSNewsReader.Properties.Settings.Default.ImportedPreviousVersionFeeds)
                {
<span style='color:green'>                    // Need to import.</span>
                    System.Xml.XmlDocument doc = new System.Xml.XmlDocument();
                    doc.Load(existingFeedFile);
                    foreach (System.Xml.XmlNode node in doc.DocumentElement.SelectNodes("feed"))
                    {
<span style='color:green'>                        // I do not get the webpage url, but I've added code so when it is loaded the htmlUrl</span>
<span style='color:green'>                        // is obtained from the feed XML document.</span>
                        this._Library.AddFeed(node.SelectSingleNode("url").InnerText, node.SelectSingleNode("title").InnerText, "");
                    }
                }
<span style='color:green'>                // Ideally I'd now do the Read section, but I've changed how the settings are saved (why? bad move)</span>
<span style='color:green'>                // so it's hard so I'm not going to do it.</span>
            }
            RSSNewsReader.Properties.Settings.Default.ImportedPreviousVersionFeeds = System.DateTime.UtcNow;
            
<span style='color:green'>            // Open any OPML file that's provided and add it to the existing list.</span>
            if (Environment.GetCommandLineArgs().Length > 1)
            {
<span style='color:green'>                // Been passed an OPML file, presumably.</span>
                string opmlFile = Environment.GetCommandLineArgs()[1];
                string url = "";
                for (int i = 1; i &lt; Environment.GetCommandLineArgs().Length; i++)
                {
                    url += Environment.GetCommandLineArgs()[i] + " ";
                }
                ImportOPML(url);
            }

            this.deletedItemsToolStripMenuItem.Checked = Properties.Settings.Default.ViewDeletedItems;
            
<span style='color:green'>            // Display the current feeds.</span>
            DisplayFeeds();
            if (lstFeeds.Items.Count > 0 && RSSNewsReader.Properties.Settings.Default.SelectedFeedIndex &lt; lstFeeds.Items.Count - 1)
            {
                lstFeeds.SelectedIndex = RSSNewsReader.Properties.Settings.Default.SelectedFeedIndex;
            }
            if (lstFeeds.SelectedIndex == -1 && lstFeeds.Items.Count > 0)
            {
                lstFeeds.SelectedIndex = 0;
            }

<span style='color:green'>            // Add sounds to list boxes.</span>
            ListBoxSounds.AddSounds(this);

<span style='color:green'>            // Set window state</span>
            this.WindowState = RSSNewsReader.Properties.Settings.Default.WindowState;

<span style='color:green'>            // Start the library refreshing the list of read/unread items.</span>
            this._Library.UpdateFeeds();
<span style='color:green'>            // Remember that we've done this.</span>
            this._LastChecked = DateTime.Now;
        }

        void _Library_LoadFinished()
        {
<span style='color:green'>            // Loaded okay!</span>
            string newText = "Loaded feed OK";
            if (this.InvokeRequired)
            {
                this.BeginInvoke(new DisplayStatusMessageDelegate(DisplayStatusMessage), newText);
                this.BeginInvoke(new DisplayItemsDelegate(DisplayItems));
            }
            else
            {
                DisplayStatusMessage(newText);
                DisplayItems();
            }
        }

        void UpdateFeedStatus(string url, string message)
        {
            int counter = 0;
            foreach (System.Xml.XmlNode outlineNode in this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline"))
            {
                string href = outlineNode.Attributes.GetNamedItem("xmlUrl").Value;
                if (href == url)
                {
<span style='color:green'>                    // Found it.</span>
                    string listItem = (string)lstFeeds.Items[counter];
                    if (listItem.EndsWith(")") && listItem.Contains("("))
                    {
                        listItem = listItem.Substring(0, listItem.LastIndexOf("(")).Trim();
                    }
                    lstFeeds.Items[counter] = listItem + " (" + _I18N.GetText("Error") + ")";
                    if (counter == lstFeeds.SelectedIndex)
                    {
                        this.lblStatus.Text = message; 
                    }
                    break;
                }
                counter++;
            }
        }

        void _Library_LoadFailed(string url, clsLibrary.ParseResult result)
        {
            string newText = _Library.ParseResultMessage;
            if (this.InvokeRequired)
            {
                object[] prms = { url, _Library.ParseResultMessage };
                this.BeginInvoke(new UpdateFeedStatusDelegate(UpdateFeedStatus), prms);
            }
            else
            {
                UpdateFeedStatus(url, _Library.ParseResultMessage);
            }
        }

        

        void DisplayStatusMessage(string message)
        {
            this.lblStatus.Text = message;
         
        }

        void _Library_LoadProgress(string message)
        {
            if (this.InvokeRequired)
            {
                this.BeginInvoke(new DisplayStatusMessageDelegate(DisplayStatusMessage), message);
            }
            else
            {
                DisplayStatusMessage(message);
            }
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// We have identified a number of unread items on an item.</span>
<span style='color:green'>        /// &lt;/summary></span>
<span style='color:green'>        /// &lt;param name="url">&lt;/param></span>
<span style='color:green'>        /// &lt;param name="count">&lt;/param></span>
        void _Library_itemCountUpdated(string url, int count)
        {
            if (this.InvokeRequired)
            {
                this.BeginInvoke(new UpdateItemCountDelegate(UpdateItemCount), url, count);
            }
            else
            {
                UpdateItemCount(url, count);
            }
        }

        void UpdateItemCount(string url, int count)
        {
            int counter = 0;
            foreach (System.Xml.XmlNode outlineNode in this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline"))
            {
                string href = outlineNode.Attributes.GetNamedItem("xmlUrl").Value;
                if (href == url)
                {
<span style='color:green'>                    // Found it.</span>
                    string listItem = (string)lstFeeds.Items[counter];
                    if (listItem.EndsWith(")") && listItem.Contains("("))
                    {
                        listItem = listItem.Substring(0, listItem.LastIndexOf("(")).Trim();
                    }
                    lstFeeds.Items[counter] = listItem + " (" + count + ")";
                }
                counter++;
            }
        }



        void _webClient_DownloadFileCompleted(object sender, AsyncCompletedEventArgs e)
        {
<span style='color:green'>            // Done downloading a feed, now open it. I can just call FeedSeleted, and now the</span>
<span style='color:green'>            // required feed will be in the cached folder!</span>
            FeedSelected();
<span style='color:green'>            //CacheFeeds(); Next version!</span>
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Iterate through the feeds and display them. </span>
<span style='color:green'>        /// &lt;/summary></span>
        private void DisplayFeeds()
        {
            this.lstFeeds.Items.Clear();
            foreach (System.Xml.XmlNode outline in this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline"))
            {
<span style='color:green'>                // It's tempting to be clever and add the outline elements directly to the list </span>
<span style='color:green'>                // control, then implement my own DrawItem to render the content. But that's </span>
<span style='color:green'>                // more complicated, so I won't. Oh, I can just override .ToString()!</span>
                lstFeeds.Items.Add(outline.Attributes.GetNamedItem("text").Value.ToString());
            }
        }

        private void lstFeeds_Click(object sender, EventArgs e)
        {
            FeedSelected();
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// A feed has been selected from the lstFeeds list. Show the news items.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private void FeedSelected()
        {
            if (lstFeeds.SelectedIndex &lt; 0 || lstFeeds.Items.Count == 0)
            {
                return;
            }
            
            lblStatus.Text = _I18N.GetText("Getting news...");
            lstItems.Items.Clear();
            
<span style='color:green'>            //// Now get the new feed XML file. We need to do this with a System.Xml.XmlTextReader to handle </span>
<span style='color:green'>            //// broken feeds.</span>
<span style='color:green'>            //System.Xml.XmlNode outlineNode = this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline")[lstFeeds.SelectedIndex]; </span>
<span style='color:green'>            //this._CurrentFeed = new RSSFeed(outlineNode.Attributes.GetNamedItem("xmlUrl").Value);</span>
<span style='color:green'>            //System.Windows.Forms.Application.DoEvents();</span>
<span style='color:green'>            //System.Windows.Forms.Application.DoEvents();</span>
<span style='color:green'>            //System.Windows.Forms.Application.DoEvents();</span>
<span style='color:green'>            //System.Windows.Forms.Application.DoEvents();</span>
<span style='color:green'>            //System.Windows.Forms.Application.DoEvents();</span>

<span style='color:green'>            //// Later, we're going to populate the htmlUrl attribute with the latest information. Make sure it's there.</span>
<span style='color:green'>            //if (outlineNode.Attributes.GetNamedItem("htmlUrl") == null)</span>
<span style='color:green'>            //{</span>
<span style='color:green'>            //    outlineNode.Attributes.SetNamedItem(this._Library.FeedsOPML.CreateAttribute("htmlUrl"));</span>
<span style='color:green'>            //}</span>

<span style='color:green'>            // Uncomment this to save the new feed XML file to the desktop - handy for debugging.</span>
<span style='color:green'>            //System.Xml.XmlDocument docSave = new System.Xml.XmlDocument();</span>
<span style='color:green'>            //docSave.Load(this._CurrentFeed.url);</span>
<span style='color:green'>            //int feedIndex = 0;</span>
<span style='color:green'>            //while (System.IO.File.Exists(Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory) + "\\Feed" + feedIndex + ".xml"))</span>
<span style='color:green'>            //{</span>
<span style='color:green'>            //    feedIndex++;</span>
<span style='color:green'>            //}</span>
<span style='color:green'>            //docSave.Save(Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory) + "\\Feed" + feedIndex + ".xml");</span>

            this._Library.SelectFeed(lstFeeds.SelectedIndex);
        }

       
        private void DisplayItems()
        {
            this.lstItems.Items.Clear();
            System.Collections.ArrayList items;
            if (Properties.Settings.Default.ViewDeletedItems)
            {
                items = this._Library.currentFeed.Items;
            }
            else
            {
                items = this._Library.currentFeed.UnreadItems;
            }
<span style='color:green'>            // Now add each item to the list </span>
            foreach (RSSItem item in items)
            {
                lstItems.Items.Add(item);
            }
            if (lstItems.Items.Count == 0)
            {
                lstItems.Items.Add(_I18N.GetText("No news items"));
                lblStatus.Text = _I18N.GetText("No news items");
            }
            else
            {
                lblStatus.Text = lstItems.Items.Count + " " + _I18N.GetText("items") + " - " + lstFeeds.Text;
            }
            lstItems.SelectedIndex = 0;
            lstItems.Focus();
        }

        private void lstItems_Click(object sender, EventArgs e)
        {
            OpenItem();
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Open the item indicated by lstItems.SelectedIndex</span>
<span style='color:green'>        /// &lt;/summary></span>
        private void OpenItem()
        {
            if (lstItems.SelectedIndex &lt; 0)
                return;

            if (this.lstItems.Items[0].GetType().ToString() == "System.String")
            {
<span style='color:green'>                // We have the "No news items!" message. Get out.</span>
                return;
            }

            RSSItem rssItem = (RSSItem)this.lstItems.Items[lstItems.SelectedIndex];
<span style='color:green'>            // We could display the contents from the RSS feed, but lots of sites don't have good contents. </span>
<span style='color:green'>            // So leave it at linking for now, like the previous version.</span>
<span style='color:green'>            //if (rssItem.contents.Length > 0)</span>
<span style='color:green'>            //{</span>
<span style='color:green'>            //    frmContent content = new frmContent();</span>
<span style='color:green'>            //    content.ParseContent(rssItem.contents);</span>
<span style='color:green'>            //    content.ShowDialog(this);</span>
<span style='color:green'>            //}</span>
<span style='color:green'>            //else</span>
<span style='color:green'>            //{</span>
            string url = rssItem.Url;
            if (url == "")
            {
                lblStatus.Text = _I18N.GetText("Failed to open story!");
            }
            else
            {
                System.Diagnostics.Process proc = new System.Diagnostics.Process();
                System.Diagnostics.ProcessStartInfo startInfo = proc.StartInfo;
                startInfo.UseShellExecute = true;
                startInfo.FileName = url;
                proc.Start();
            }
<span style='color:green'>            //}</span>
        }

        private void mnuFileImport_Click(object sender, EventArgs e)
        {
            System.Windows.Forms.OpenFileDialog ofd = new System.Windows.Forms.OpenFileDialog();
            ofd.CheckFileExists = true;
            ofd.DefaultExt = "opml";
            ofd.Filter = "OPML files|*.opml";
            if (ofd.ShowDialog() == System.Windows.Forms.DialogResult.OK)
            {
                ImportOPML(ofd.FileName);
                DisplayFeeds();
            }
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Imports an OPML file, adding any feeds not already in the list.</span>
<span style='color:green'>        /// &lt;/summary></span>
<span style='color:green'>        /// &lt;param name="filename">&lt;/param></span>
        private void ImportOPML(string filename)
        {
            System.Xml.XmlDocument newFeedDoc = new System.Xml.XmlDocument();
            try
            {
                newFeedDoc.Load(filename);
            }
            catch (System.Xml.XmlException xmlEx)
            {
                MessageBox.Show(this, xmlEx.Message, Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                return;
            }
            catch (System.IO.FileNotFoundException fnfEx)
            {
                MessageBox.Show(this, fnfEx.Message, Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                return;
            }
            int added = 0;
            foreach (System.Xml.XmlNode outlineNode in newFeedDoc.DocumentElement.SelectNodes("body/outline"))
            {
                string href = outlineNode.Attributes.GetNamedItem("xmlUrl").Value;
                if (this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline[@xmlUrl=\"" + href + "\"]").Count == 0)
                {
<span style='color:green'>                    // This feed doesn't exist, add it. </span>
                    System.Xml.XmlNode importedFeedNode = this._Library.FeedsOPML.ImportNode(outlineNode, true);
                    this._Library.FeedsOPML.DocumentElement.SelectSingleNode("body").AppendChild(importedFeedNode);
                    added++;
                }
            }
            if (added > 0)
            {
<span style='color:green'>                // Need to sort!</span>
                SortFeeds();
            }
            this.lblStatus.Text = _I18N.GetText("Imported") + " " + added + " " + _I18N.GetText("new feeds.");
            DisplayFeeds();
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Sort the feed list (which is an OPML file) by title.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private void SortFeeds()
        {
            if (this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline").Count &lt; 2)
                return;

            bool swapped = true;
            while (swapped)
            {
                swapped = false;
                for (int i = 0; i &lt; this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline").Count - 1; i++)
                {
                    System.Xml.XmlNode firstNode = this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline")[i];
                    System.Xml.XmlNode secondNode = this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline")[i + 1];
                    string firstTitle = firstNode.Attributes.GetNamedItem("title").InnerText;
                    string secondTitle = secondNode.Attributes.GetNamedItem("title").InnerText;
                    if (string.Compare(firstTitle, secondTitle, true, System.Globalization.CultureInfo.CurrentCulture) > 0)
                    {
<span style='color:green'>                        // Need to swap.</span>
                        swapped = true;
                        System.Xml.XmlNode tempNode = this._Library.FeedsOPML.DocumentElement.SelectSingleNode("body").RemoveChild(secondNode);
                        this._Library.FeedsOPML.DocumentElement.SelectSingleNode("body").InsertBefore(tempNode, firstNode);
                    }
                }
            }
        }

        private void frmMain_FormClosed(object sender, FormClosedEventArgs e)
        {
<span style='color:green'>            // Save the feeds we're using.</span>
            this._Library.Save();
<span style='color:green'>            // Save the current feed</span>
            RSSNewsReader.Properties.Settings.Default.SelectedFeedIndex = lstFeeds.SelectedIndex;
<span style='color:green'>            // Save the window state</span>
            if (this.WindowState == FormWindowState.Normal)
            {
                RSSNewsReader.Properties.Settings.Default.WindowState = FormWindowState.Normal;
            }
            else if (this.WindowState == FormWindowState.Maximized)
            {
                RSSNewsReader.Properties.Settings.Default.WindowState = FormWindowState.Maximized;
            }
<span style='color:green'>            // Save our settings</span>
            RSSNewsReader.Properties.Settings.Default.Save();
        }

        private void refreshToolStripMenuItem_Click(object sender, EventArgs e)
        {
            FeedSelected();
        }

        private void nextToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (lstFeeds.SelectedIndex &lt; lstFeeds.Items.Count - 1)
            {
                lstFeeds.SelectedIndex++;
                FeedSelected();
            }
            else
            {
                Microsoft.VisualBasic.Interaction.Beep();
            }
        }

        private void previousToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (lstFeeds.SelectedIndex > 0)
            {
                lstFeeds.SelectedIndex--;
                FeedSelected();
            }
            else
            {
                Microsoft.VisualBasic.Interaction.Beep();
            }
        }


<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Delete the currently-selected feed, if there is one.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private void DeleteSelectedFeed()
        {
            if (lstFeeds.SelectedIndex != -1)
            {
                this._Library.RemoveFeed(lstFeeds.SelectedIndex);
                if (this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline").Count == 0)
                {
                    lstFeeds.Items.Clear();
                }
                else
                {
                    if (lstFeeds.SelectedIndex == lstFeeds.Items.Count - 1)
                    {
                        lstFeeds.SelectedIndex = lstFeeds.Items.Count - 2;
                    }
                    int selected = lstFeeds.SelectedIndex;
                    DisplayFeeds();
                    lstFeeds.SelectedIndex = selected;
                    FeedSelected();
                }
            }
            else
            {
                Microsoft.VisualBasic.Interaction.Beep();
            }
        }

        private void deleteFeedToolStripMenuItem_Click(object sender, EventArgs e)
        {
            DeleteSelectedFeed();
        }

        private void lstFeeds_SelectedIndexChanged(object sender, EventArgs e)
        {
            this.deleteFeedToolStripMenuItem.Enabled = (lstFeeds.SelectedIndex != -1);
            this.renameFeedToolStripMenuItem.Enabled = this.deletedItemsToolStripMenuItem.Enabled;
        }

        private void addFeedToolStripMenuItem_Click(object sender, EventArgs e)
        {
            string newUrl = Microsoft.VisualBasic.Interaction.InputBox(_I18N.GetText("Enter URL:"), Application.ProductName);
            if (newUrl.Length == 0)
                return;
            this.staMain.Text = "";
            if (!newUrl.ToLowerInvariant().StartsWith("http"))
            {
                newUrl = "http://" + newUrl;
            }
<span style='color:green'>            //The MSDN documentation says it's best to create an XmlTextReader through .Create</span>
<span style='color:green'>            //rather than = new XmlTextReader. However, if you do it through new, you get an</span>
<span style='color:green'>            //XmlTextReader that doesn't choke on malformed XML, and if you do it through</span>
<span style='color:green'>            //.Create you choke on malformed XML. So clearly new is better!</span>
            System.Xml.XmlTextReader xtr;
            try
            {
                xtr = new System.Xml.XmlTextReader(newUrl);
            }
            catch (System.UriFormatException ufe)
            {
<span style='color:green'>                // Not a valid URL. Skip trying to analyse.</span>
                MessageBox.Show(_I18N.GetText("Invalid URL:") + " " + ufe.Message, Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }
            catch (Exception ex)
            {
<span style='color:green'>                // Unknown error - File Not Found, possibly - display and quit.</span>
                MessageBox.Show(ex.Message, Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
            string newFeedUrl = "";
            string rootNodeName = "";
            bool finishedSearching = false;
            bool readOK = true;
            while (!xtr.EOF && !finishedSearching && readOK)
            {
                try
                {
                    readOK = xtr.Read();
                    if (xtr.NodeType == System.Xml.XmlNodeType.Element)
                    {
                        string elementName = xtr.Name.ToLowerInvariant();
<span style='color:green'>                        // If this is the first node then it is the root node. </span>
<span style='color:green'>                        // Remember the name so that we know what type of document</span>
<span style='color:green'>                        // the user has given us - Atom, RSS, or a web page to</span>
<span style='color:green'>                        // search.</span>
                        System.Diagnostics.Debug.Print("Node:" + elementName);
                        if (rootNodeName.Length == 0)
                        {
                            rootNodeName = elementName;
                        }
                        if (rootNodeName == "html")
                        {
<span style='color:green'>                            // This is an HTML file, scan it for RSS feeds.</span>
                            if (elementName == "link")
                            {
<span style='color:green'>                                // Got a link: is it valid?</span>
                                if (xtr.HasAttributes)
                                {
                                    string href = xtr.GetAttribute("href");
                                    string rel = xtr.GetAttribute("rel");
                                    if (rel.ToLowerInvariant() == "alternate" && href != "")
                                    {
<span style='color:green'>                                        // Got it!</span>
                                        newFeedUrl = href;
                                        finishedSearching = true;
                                    }
                                }
                            }
                        }
                        else if (rootNodeName == "feed" || rootNodeName == "rss")
                        {
<span style='color:green'>                            // It's an RSS/Atom feed, go ahead and add it </span>
<span style='color:green'>                            // without further checking, and stop reading</span>
<span style='color:green'>                            // this document.</span>
                            newFeedUrl = newUrl;
                            finishedSearching = true;
                        }
                    }
                }
                catch
                {
<span style='color:green'>                    //Parsing error from the web page or XML = very common, carry on going</span>
<span style='color:green'>                    //until we find something useful.</span>
                }
                System.Windows.Forms.Application.DoEvents();
            }
            xtr.Close();

<span style='color:green'>            // OK, so we've examined the url the user gave us. Found anything?</span>
            if (newFeedUrl == "")
            {
<span style='color:green'>                // Failed to find anything!</span>
                MessageBox.Show(_I18N.GetText("No RSS news feeds found"), Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            else
            {
<span style='color:green'>                // OK, try getting it. </span>
                System.Xml.XmlTextReader newFeed = new System.Xml.XmlTextReader(newFeedUrl);
                string newTitle = "";
                string newWebsiteUrl = "";
                bool foundTitleAndUrl = false;
                bool nextNodeIsTitle = false;
                bool nextNodeIsWebsiteUrl = false;
                readOK = true;
                while (!newFeed.EOF && !foundTitleAndUrl && readOK)
                {
                    try
                    {
                        readOK = newFeed.Read();
                        if (newFeed.NodeType == System.Xml.XmlNodeType.Element)
                        {
                            System.Diagnostics.Debug.Print("Node:" + newFeed.Name.ToLowerInvariant());
                            if (newFeed.Name.ToLowerInvariant() == "title")
                            {
                                if (newTitle == "")
                                {
                                    nextNodeIsTitle = true;
                                }
                            }
                            else if (newFeed.Name.ToLowerInvariant() == "link")
                            {
                                if (newWebsiteUrl == "")
                                {
                                    nextNodeIsWebsiteUrl = true;
                                }
                            }
                        }
                        else if (newFeed.NodeType == System.Xml.XmlNodeType.Text)
                        {
                            if (nextNodeIsTitle)
                            {
                                newTitle = newFeed.Value;
                                nextNodeIsTitle = false;
                            }
                            if (nextNodeIsWebsiteUrl)
                            {
                                newWebsiteUrl = newFeed.Value;
                                nextNodeIsWebsiteUrl = false;
                            }
                        }
                    }
                    catch
                    {
<span style='color:green'>                        // Error in XML, very common, carry on.</span>
                    }
                    if (newTitle.Length > 0 && newWebsiteUrl.Length > 0)
                    {
                        foundTitleAndUrl = true;
                    }
                    System.Windows.Forms.Application.DoEvents();
                }
                newFeed.Close();
<span style='color:green'>                // OK, add to lists!</span>
                if (foundTitleAndUrl)
                {
<span style='color:green'>                    // Assume this is good.</span>
                    this._Library.AddFeed(newFeedUrl, newTitle, newWebsiteUrl);
                    SortFeeds();
                    DisplayFeeds();
                    lblStatus.Text = _I18N.GetText("Added:") + " " + newTitle;
                    lstFeeds.SelectedIndex = lstFeeds.Items.Count - 1;
                    try
                    {
<span style='color:green'>                        // Submission of RSS feed to database.</span>
                        newTitle = System.Net.WebUtility.HtmlEncode(newTitle);
                        newUrl = System.Net.WebUtility.HtmlEncode(newUrl);
                        System.Net.HttpWebRequest wr = (System.Net.HttpWebRequest)System.Net.WebRequest.Create("http://data.webbie.org.uk/newRSSFeed.php?title=" + newTitle + "&url=" + newFeedUrl + "&language=" + this._I18N.GetLanguage());
                        wr.KeepAlive = false;
                        wr.Method = System.Net.WebRequestMethods.Http.Get;
                        wr.ContentType = "text/html";
                        wr.AllowAutoRedirect = true;
                        wr.GetResponse();
                    }
                    catch
                    {
<span style='color:green'>                        // Failed to connect and write feed information: record why to error log.</span>
                        System.Diagnostics.EventLog.WriteEntry(Application.ProductName + " " + Application.ProductVersion, "Failed to submit new feed registration to WebbIE (" + newUrl + ")");
                    }
                }
                else
                {
<span style='color:green'>                    // Not found a feed.</span>
                    staMain.Text = this._I18N.GetText("0 feeds found.");
                }
            }
        }

        private void mnuFileExport_Click(object sender, EventArgs e)
        {
            System.Windows.Forms.SaveFileDialog sfd = new System.Windows.Forms.SaveFileDialog();
            sfd.CheckPathExists = true;
            sfd.AddExtension = true;
            sfd.DefaultExt = "opml";
            sfd.Filter = "OPML Files|*.opml";
            sfd.FileName = "RSS News Feeds.opml";
            if (sfd.ShowDialog() == System.Windows.Forms.DialogResult.OK)
            {
                try
                {
                    this._Library.ExportFeedOPML(sfd.FileName);
                }
                catch (Exception ex)
                {
                    System.Diagnostics.EventLog.WriteEntry(Application.ProductName + " " + Application.ProductVersion, "Failed to export OPML file: " + ex.Message);
                }
            }
        }

        private void openFeedWebsiteToolStripMenuItem_Click(object sender, EventArgs e)
        {
            System.Xml.XmlNode currentFeed = this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline")[lstFeeds.SelectedIndex];
            if (currentFeed.Attributes.GetNamedItem("htmlUrl") == null)
            {
<span style='color:green'>                // Missing http value. We'll populate it from the feed next time we load it (so in theory we should</span>
<span style='color:green'>                // never get here!)</span>
                Microsoft.VisualBasic.Interaction.Beep();
            }
            else
            {
                System.Diagnostics.Process.Start(currentFeed.Attributes.GetNamedItem("htmlUrl").InnerText);
            }
        }

        private void lstItems_KeyUp(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete && lstItems.SelectedIndex > -1 && lstItems.Text != _I18N.GetText("No news items"))
            {
                MarkCurrentItemAsRead();
            }
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Mark the currently-selected item as read - that is, remove it from</span>
<span style='color:green'>        /// display.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private void MarkCurrentItemAsRead()
        {
            if (this.lstItems.SelectedIndex == -1)
                return;

            MarkItemAsRead(this.lstItems.SelectedIndex);
            UpdateItemCount(_Library.currentFeed.url, _Library.currentFeed.UnreadItems.Count);
            int index = lstItems.SelectedIndex;
            DisplayItems();
            if (index &lt; lstItems.Items.Count && lstItems.Items.Count > 0)
            {
                lstItems.SelectedIndex = index;
            }
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Set the item indicated by index (to the list of items) to "read"</span>
<span style='color:green'>        /// &lt;/summary></span>
<span style='color:green'>        /// &lt;param name="index">&lt;/param></span>
        private void MarkItemAsRead(int index)
        {
            RSSItem rssItem = (RSSItem)lstItems.Items[index];
            this._Library.currentFeed.MarkAsRead(rssItem);
        }
        
        private void lstItems_SelectedIndexChanged(object sender, EventArgs e)
        {

        }

        private void lstFeeds_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Return)
            {
                FeedSelected();
            }
            else if (e.KeyCode == Keys.Delete)
            {
                DeleteSelectedFeed();
            }
        }

        private void deletedItemsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            RSSNewsReader.Properties.Settings.Default.ViewDeletedItems = !RSSNewsReader.Properties.Settings.Default.ViewDeletedItems;
            this.deletedItemsToolStripMenuItem.Checked = RSSNewsReader.Properties.Settings.Default.ViewDeletedItems;
            FeedSelected();
        }

        private void mnuWebsiteDeleteallwebsitefeeds_Click(object sender, EventArgs e)
        {
            if (MessageBox.Show(_I18N.GetText("Do you really want to delete every RSS news feed?"), Application.ProductName, MessageBoxButtons.YesNoCancel, MessageBoxIcon.Question) == DialogResult.Yes)
            {
<span style='color:green'>                // Remove every feed.</span>
                this._Library.RemoveAllFeeds();
                this.lstFeeds.Items.Clear();
                this.lstItems.Items.Clear();
            }
        }

        private void mnuHelpManual_Click(object sender, EventArgs e)
        {
            _I18N.ShowHelp();
        }

        private void mnuHelpAbout_Click(object sender, EventArgs e)
        {
            MessageBox.Show(this, Application.ProductName + "\t" + Application.ProductVersion, Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Information);
        }

        private void lstItems_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Return)
            {
                OpenItem();
            }
            else if (e.KeyCode == Keys.Escape)
            {
<span style='color:green'>                // Go to feeds list.</span>
                lstFeeds.Focus();
            }
        }

        private void deleteToolStripMenuItem_Click(object sender, EventArgs e)
        {
            MarkCurrentItemAsRead();
        }

        private void renameFeedToolStripMenuItem_Click(object sender, EventArgs e)
        {
            RenameSelectedFeed();
        }

        private void RenameSelectedFeed()
        {
            if (lstFeeds.SelectedIndex &lt; 0)
                return;

            string newName = Microsoft.VisualBasic.Interaction.InputBox("Enter a new name for the feed:", Application.ProductName, lstFeeds.Text);
            if (newName.Length > 0)
            {
                System.Xml.XmlNode outlineNode = this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline")[lstFeeds.SelectedIndex];
                outlineNode.Attributes.GetNamedItem("text").Value = newName;
                outlineNode.Attributes.GetNamedItem("title").Value = newName;
                string url = outlineNode.Attributes.GetNamedItem("xmlUrl").Value;
                SortFeeds();
                DisplayFeeds();

<span style='color:green'>                // Set focus back to this newly-renamed feed</span>
                System.Xml.XmlNodeList feedList = this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline");
                for (int i = 0; i &lt; feedList.Count; i++)
                {
                    if (feedList.Item(i).Attributes.GetNamedItem("xmlUrl").Value == url)
                    {
<span style='color:green'>                        // This is the one!</span>
                        lstFeeds.SelectedIndex = i;
                        break;
                    }

                }
            }
            
        }

        private void lstFeeds_DoubleClick(object sender, EventArgs e)
        {
            FeedSelected();
        }

        private void downloadFeedToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (lstFeeds.SelectedIndex != -1)
            {
                System.Xml.XmlNode outlineNode = this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline")[lstFeeds.SelectedIndex];
                string url = outlineNode.Attributes.GetNamedItem("xmlUrl").Value;
            
                System.Net.WebClient wc = new System.Net.WebClient();
                int index = 1;
                while (System.IO.File.Exists(Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory) + "\\feed" + index + ".xml"))
                {
                    index++;
                }
                wc.DownloadFile(url, Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory) + "\\feed" + index + ".xml");
            }
        }

        private void deleteallToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (lstItems.Text == _I18N.GetText("No news items"))
                return;

            for (int i = 0; i &lt; lstItems.Items.Count; i++)
            {
                MarkItemAsRead(i);
            }
            DisplayItems();
            lstItems.SelectedIndex = 0;
        }

        private void tmrCheckForNewItems_Tick(object sender, EventArgs e)
        {
            if (this._LastChecked + new TimeSpan(0,5,0) &lt; DateTime.Now)
            {
<span style='color:green'>                // Need to check now!</span>
                this._LastChecked = DateTime.Now;
                this._Library.UpdateFeeds();
            }
        }

        private void openFeedURlToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (this.lstFeeds.SelectedIndex == 0)
            {
                return;
            }
            System.Xml.XmlNode outlineNode = this._Library.FeedsOPML.DocumentElement.SelectNodes("body/outline")[this.lstFeeds.SelectedIndex];
            string xmlUrl = outlineNode.Attributes.GetNamedItem("xmlUrl").Value;
            System.Diagnostics.Process proc = new System.Diagnostics.Process();
            System.Diagnostics.ProcessStartInfo startInfo = proc.StartInfo;
            startInfo.UseShellExecute = true;
            startInfo.FileName = "iexplore";
            startInfo.Arguments = xmlUrl;
            proc.Start();
        }

        private void deleteAllToolStripMenuItem_Click_1(object sender, EventArgs e)
        {
            MarkAllItemsAsRead();
        }

        private void MarkAllItemsAsRead()
        {
            this._Library.currentFeed.MarkAllAsRead();
            DisplayItems();
            UpdateItemCount(this._Library.currentFeed.url, 0);
        }

     
    }

}
</pre>
</div>
<div class='csfile'>
<h2 id='frmMain.designer.cs'>frmMain.designer.cs</h2>
<pre>
namespace RSSNewsReader
{
    partial class frmMain
    {
<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Required designer variable.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private System.ComponentModel.IContainer components = null;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Clean up any resources being used.</span>
<span style='color:green'>        /// &lt;/summary></span>
<span style='color:green'>        /// &lt;param name="disposing">true if managed resources should be disposed; otherwise, false.&lt;/param></span>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Required method for Designer support - do not modify</span>
<span style='color:green'>        /// the contents of this method with the code editor.</span>
<span style='color:green'>        /// &lt;/summary></span>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(frmMain));
            this.menuStrip1 = new System.Windows.Forms.MenuStrip();
            this.mnuFile = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuFileImport = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuFileExport = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuFileExit = new System.Windows.Forms.ToolStripMenuItem();
            this.viewToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.deletedItemsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuFeeds = new System.Windows.Forms.ToolStripMenuItem();
            this.refreshToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuFeedsNext = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuFeedsPrevious = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem1 = new System.Windows.Forms.ToolStripSeparator();
            this.mnuWebsiteAdd = new System.Windows.Forms.ToolStripMenuItem();
            this.renameFeedToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.deleteFeedToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.openFeedWebsiteToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem2 = new System.Windows.Forms.ToolStripSeparator();
            this.mnuFeedsDeleteallwebsitefeeds = new System.Windows.Forms.ToolStripMenuItem();
            this.itemsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.deleteToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuHelp = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuHelpManual = new System.Windows.Forms.ToolStripMenuItem();
            this.openFeedURlToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuHelpAbout = new System.Windows.Forms.ToolStripMenuItem();
            this.staMain = new System.Windows.Forms.StatusStrip();
            this.lblStatus = new System.Windows.Forms.ToolStripStatusLabel();
            this.splitContainer1 = new System.Windows.Forms.SplitContainer();
            this.lstFeeds = new System.Windows.Forms.ListBox();
            this.lstItems = new System.Windows.Forms.ListBox();
            this.tmrCheckForNewItems = new System.Windows.Forms.Timer(this.components);
            this.deleteAllToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.menuStrip1.SuspendLayout();
            this.staMain.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();
            this.splitContainer1.Panel1.SuspendLayout();
            this.splitContainer1.Panel2.SuspendLayout();
            this.splitContainer1.SuspendLayout();
            this.SuspendLayout();
<span style='color:green'>            // </span>
<span style='color:green'>            // menuStrip1</span>
<span style='color:green'>            // </span>
            this.menuStrip1.Font = new System.Drawing.Font("Segoe UI", 15.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.mnuFile,
            this.viewToolStripMenuItem,
            this.mnuFeeds,
            this.itemsToolStripMenuItem,
            this.mnuHelp});
            this.menuStrip1.Location = new System.Drawing.Point(0, 0);
            this.menuStrip1.Name = "menuStrip1";
            this.menuStrip1.Size = new System.Drawing.Size(568, 38);
            this.menuStrip1.TabIndex = 0;
            this.menuStrip1.Text = "menuStrip1";
<span style='color:green'>            // </span>
<span style='color:green'>            // mnuFile</span>
<span style='color:green'>            // </span>
            this.mnuFile.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.mnuFileImport,
            this.mnuFileExport,
            this.mnuFileExit});
            this.mnuFile.Name = "mnuFile";
            this.mnuFile.Size = new System.Drawing.Size(56, 34);
            this.mnuFile.Text = "&File";
<span style='color:green'>            // </span>
<span style='color:green'>            // mnuFileImport</span>
<span style='color:green'>            // </span>
            this.mnuFileImport.Name = "mnuFileImport";
            this.mnuFileImport.Size = new System.Drawing.Size(148, 34);
            this.mnuFileImport.Text = "&Import";
            this.mnuFileImport.Click += new System.EventHandler(this.mnuFileImport_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // mnuFileExport</span>
<span style='color:green'>            // </span>
            this.mnuFileExport.Name = "mnuFileExport";
            this.mnuFileExport.Size = new System.Drawing.Size(148, 34);
            this.mnuFileExport.Text = "&Export";
            this.mnuFileExport.Click += new System.EventHandler(this.mnuFileExport_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // mnuFileExit</span>
<span style='color:green'>            // </span>
            this.mnuFileExit.Name = "mnuFileExit";
            this.mnuFileExit.Size = new System.Drawing.Size(148, 34);
            this.mnuFileExit.Text = "E&xit";
            this.mnuFileExit.Click += new System.EventHandler(this.exitToolStripMenuItem_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // viewToolStripMenuItem</span>
<span style='color:green'>            // </span>
            this.viewToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.deletedItemsToolStripMenuItem});
            this.viewToolStripMenuItem.Name = "viewToolStripMenuItem";
            this.viewToolStripMenuItem.Size = new System.Drawing.Size(69, 34);
            this.viewToolStripMenuItem.Text = "&View";
<span style='color:green'>            // </span>
<span style='color:green'>            // deletedItemsToolStripMenuItem</span>
<span style='color:green'>            // </span>
            this.deletedItemsToolStripMenuItem.Name = "deletedItemsToolStripMenuItem";
            this.deletedItemsToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.D)));
            this.deletedItemsToolStripMenuItem.Size = new System.Drawing.Size(288, 34);
            this.deletedItemsToolStripMenuItem.Text = "&Deleted items";
            this.deletedItemsToolStripMenuItem.Click += new System.EventHandler(this.deletedItemsToolStripMenuItem_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // mnuFeeds</span>
<span style='color:green'>            // </span>
            this.mnuFeeds.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.refreshToolStripMenuItem,
            this.mnuFeedsNext,
            this.mnuFeedsPrevious,
            this.toolStripMenuItem1,
            this.mnuWebsiteAdd,
            this.renameFeedToolStripMenuItem,
            this.deleteFeedToolStripMenuItem,
            this.openFeedWebsiteToolStripMenuItem,
            this.toolStripMenuItem2,
            this.mnuFeedsDeleteallwebsitefeeds});
            this.mnuFeeds.Name = "mnuFeeds";
            this.mnuFeeds.Size = new System.Drawing.Size(78, 34);
            this.mnuFeeds.Text = "F&eeds";
<span style='color:green'>            // </span>
<span style='color:green'>            // refreshToolStripMenuItem</span>
<span style='color:green'>            // </span>
            this.refreshToolStripMenuItem.Name = "refreshToolStripMenuItem";
            this.refreshToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.R)));
            this.refreshToolStripMenuItem.Size = new System.Drawing.Size(260, 34);
            this.refreshToolStripMenuItem.Text = "Refresh";
            this.refreshToolStripMenuItem.Click += new System.EventHandler(this.refreshToolStripMenuItem_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // mnuFeedsNext</span>
<span style='color:green'>            // </span>
            this.mnuFeedsNext.Name = "mnuFeedsNext";
            this.mnuFeedsNext.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Down)));
            this.mnuFeedsNext.Size = new System.Drawing.Size(260, 34);
            this.mnuFeedsNext.Text = "Next";
            this.mnuFeedsNext.Click += new System.EventHandler(this.nextToolStripMenuItem_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // mnuFeedsPrevious</span>
<span style='color:green'>            // </span>
            this.mnuFeedsPrevious.Name = "mnuFeedsPrevious";
            this.mnuFeedsPrevious.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Up)));
            this.mnuFeedsPrevious.Size = new System.Drawing.Size(260, 34);
            this.mnuFeedsPrevious.Text = "Previous";
            this.mnuFeedsPrevious.Click += new System.EventHandler(this.previousToolStripMenuItem_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // toolStripMenuItem1</span>
<span style='color:green'>            // </span>
            this.toolStripMenuItem1.Name = "toolStripMenuItem1";
            this.toolStripMenuItem1.Size = new System.Drawing.Size(257, 6);
<span style='color:green'>            // </span>
<span style='color:green'>            // mnuWebsiteAdd</span>
<span style='color:green'>            // </span>
            this.mnuWebsiteAdd.Name = "mnuWebsiteAdd";
            this.mnuWebsiteAdd.Size = new System.Drawing.Size(260, 34);
            this.mnuWebsiteAdd.Text = "Add feed";
            this.mnuWebsiteAdd.Click += new System.EventHandler(this.addFeedToolStripMenuItem_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // renameFeedToolStripMenuItem</span>
<span style='color:green'>            // </span>
            this.renameFeedToolStripMenuItem.Enabled = false;
            this.renameFeedToolStripMenuItem.Name = "renameFeedToolStripMenuItem";
            this.renameFeedToolStripMenuItem.ShortcutKeys = System.Windows.Forms.Keys.F2;
            this.renameFeedToolStripMenuItem.Size = new System.Drawing.Size(260, 34);
            this.renameFeedToolStripMenuItem.Text = "&Rename feed";
            this.renameFeedToolStripMenuItem.Click += new System.EventHandler(this.renameFeedToolStripMenuItem_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // deleteFeedToolStripMenuItem</span>
<span style='color:green'>            // </span>
            this.deleteFeedToolStripMenuItem.Enabled = false;
            this.deleteFeedToolStripMenuItem.Name = "deleteFeedToolStripMenuItem";
            this.deleteFeedToolStripMenuItem.Size = new System.Drawing.Size(260, 34);
            this.deleteFeedToolStripMenuItem.Text = "Delete feed";
            this.deleteFeedToolStripMenuItem.Click += new System.EventHandler(this.deleteFeedToolStripMenuItem_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // openFeedWebsiteToolStripMenuItem</span>
<span style='color:green'>            // </span>
            this.openFeedWebsiteToolStripMenuItem.Name = "openFeedWebsiteToolStripMenuItem";
            this.openFeedWebsiteToolStripMenuItem.Size = new System.Drawing.Size(260, 34);
            this.openFeedWebsiteToolStripMenuItem.Text = "Open feed website";
            this.openFeedWebsiteToolStripMenuItem.Click += new System.EventHandler(this.openFeedWebsiteToolStripMenuItem_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // toolStripMenuItem2</span>
<span style='color:green'>            // </span>
            this.toolStripMenuItem2.Name = "toolStripMenuItem2";
            this.toolStripMenuItem2.Size = new System.Drawing.Size(257, 6);
<span style='color:green'>            // </span>
<span style='color:green'>            // mnuFeedsDeleteallwebsitefeeds</span>
<span style='color:green'>            // </span>
            this.mnuFeedsDeleteallwebsitefeeds.Name = "mnuFeedsDeleteallwebsitefeeds";
            this.mnuFeedsDeleteallwebsitefeeds.Size = new System.Drawing.Size(260, 34);
            this.mnuFeedsDeleteallwebsitefeeds.Text = "Delete all feeds";
            this.mnuFeedsDeleteallwebsitefeeds.Click += new System.EventHandler(this.mnuWebsiteDeleteallwebsitefeeds_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // itemsToolStripMenuItem</span>
<span style='color:green'>            // </span>
            this.itemsToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.deleteToolStripMenuItem,
            this.deleteAllToolStripMenuItem});
            this.itemsToolStripMenuItem.Name = "itemsToolStripMenuItem";
            this.itemsToolStripMenuItem.Size = new System.Drawing.Size(76, 34);
            this.itemsToolStripMenuItem.Text = "&Items";
<span style='color:green'>            // </span>
<span style='color:green'>            // deleteToolStripMenuItem</span>
<span style='color:green'>            // </span>
            this.deleteToolStripMenuItem.Name = "deleteToolStripMenuItem";
            this.deleteToolStripMenuItem.Size = new System.Drawing.Size(176, 34);
            this.deleteToolStripMenuItem.Text = "&Delete";
            this.deleteToolStripMenuItem.Click += new System.EventHandler(this.deleteToolStripMenuItem_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // mnuHelp</span>
<span style='color:green'>            // </span>
            this.mnuHelp.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.mnuHelpManual,
            this.openFeedURlToolStripMenuItem,
            this.mnuHelpAbout});
            this.mnuHelp.Name = "mnuHelp";
            this.mnuHelp.Size = new System.Drawing.Size(68, 34);
            this.mnuHelp.Text = "&Help";
<span style='color:green'>            // </span>
<span style='color:green'>            // mnuHelpManual</span>
<span style='color:green'>            // </span>
            this.mnuHelpManual.Name = "mnuHelpManual";
            this.mnuHelpManual.ShortcutKeys = System.Windows.Forms.Keys.F1;
            this.mnuHelpManual.Size = new System.Drawing.Size(227, 34);
            this.mnuHelpManual.Text = "&Manual";
            this.mnuHelpManual.Click += new System.EventHandler(this.mnuHelpManual_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // openFeedURlToolStripMenuItem</span>
<span style='color:green'>            // </span>
            this.openFeedURlToolStripMenuItem.Name = "openFeedURlToolStripMenuItem";
            this.openFeedURlToolStripMenuItem.Size = new System.Drawing.Size(227, 34);
            this.openFeedURlToolStripMenuItem.Text = "Open feed URL";
            this.openFeedURlToolStripMenuItem.Click += new System.EventHandler(this.openFeedURlToolStripMenuItem_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // mnuHelpAbout</span>
<span style='color:green'>            // </span>
            this.mnuHelpAbout.Name = "mnuHelpAbout";
            this.mnuHelpAbout.Size = new System.Drawing.Size(227, 34);
            this.mnuHelpAbout.Text = "&About";
            this.mnuHelpAbout.Click += new System.EventHandler(this.mnuHelpAbout_Click);
<span style='color:green'>            // </span>
<span style='color:green'>            // staMain</span>
<span style='color:green'>            // </span>
            this.staMain.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.lblStatus});
            this.staMain.Location = new System.Drawing.Point(0, 580);
            this.staMain.Name = "staMain";
            this.staMain.Size = new System.Drawing.Size(568, 22);
            this.staMain.TabIndex = 1;
            this.staMain.Text = "statusStrip1";
<span style='color:green'>            // </span>
<span style='color:green'>            // lblStatus</span>
<span style='color:green'>            // </span>
            this.lblStatus.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Text;
            this.lblStatus.Font = new System.Drawing.Font("Segoe UI", 15.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblStatus.Name = "lblStatus";
            this.lblStatus.Overflow = System.Windows.Forms.ToolStripItemOverflow.Never;
            this.lblStatus.Size = new System.Drawing.Size(553, 17);
            this.lblStatus.Spring = true;
            this.lblStatus.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
<span style='color:green'>            // </span>
<span style='color:green'>            // splitContainer1</span>
<span style='color:green'>            // </span>
            this.splitContainer1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.splitContainer1.Location = new System.Drawing.Point(0, 38);
            this.splitContainer1.Name = "splitContainer1";
<span style='color:green'>            // </span>
<span style='color:green'>            // splitContainer1.Panel1</span>
<span style='color:green'>            // </span>
            this.splitContainer1.Panel1.Controls.Add(this.lstFeeds);
<span style='color:green'>            // </span>
<span style='color:green'>            // splitContainer1.Panel2</span>
<span style='color:green'>            // </span>
            this.splitContainer1.Panel2.Controls.Add(this.lstItems);
            this.splitContainer1.Size = new System.Drawing.Size(568, 542);
            this.splitContainer1.SplitterDistance = 189;
            this.splitContainer1.TabIndex = 2;
<span style='color:green'>            // </span>
<span style='color:green'>            // lstFeeds</span>
<span style='color:green'>            // </span>
            this.lstFeeds.AccessibleName = "Feed &list";
            this.lstFeeds.Dock = System.Windows.Forms.DockStyle.Fill;
            this.lstFeeds.FormattingEnabled = true;
            this.lstFeeds.IntegralHeight = false;
            this.lstFeeds.ItemHeight = 30;
            this.lstFeeds.Location = new System.Drawing.Point(0, 0);
            this.lstFeeds.Name = "lstFeeds";
            this.lstFeeds.Size = new System.Drawing.Size(189, 542);
            this.lstFeeds.TabIndex = 0;
            this.lstFeeds.Click += new System.EventHandler(this.lstFeeds_Click);
            this.lstFeeds.SelectedIndexChanged += new System.EventHandler(this.lstFeeds_SelectedIndexChanged);
            this.lstFeeds.KeyDown += new System.Windows.Forms.KeyEventHandler(this.lstFeeds_KeyDown);
<span style='color:green'>            // </span>
<span style='color:green'>            // lstItems</span>
<span style='color:green'>            // </span>
            this.lstItems.AccessibleName = "&Results";
            this.lstItems.Dock = System.Windows.Forms.DockStyle.Fill;
            this.lstItems.FormattingEnabled = true;
            this.lstItems.IntegralHeight = false;
            this.lstItems.ItemHeight = 30;
            this.lstItems.Location = new System.Drawing.Point(0, 0);
            this.lstItems.Name = "lstItems";
            this.lstItems.Size = new System.Drawing.Size(375, 542);
            this.lstItems.TabIndex = 0;
            this.lstItems.Click += new System.EventHandler(this.lstItems_Click);
            this.lstItems.SelectedIndexChanged += new System.EventHandler(this.lstItems_SelectedIndexChanged);
            this.lstItems.KeyDown += new System.Windows.Forms.KeyEventHandler(this.lstItems_KeyDown);
            this.lstItems.KeyUp += new System.Windows.Forms.KeyEventHandler(this.lstItems_KeyUp);
<span style='color:green'>            // </span>
<span style='color:green'>            // tmrCheckForNewItems</span>
<span style='color:green'>            // </span>
            this.tmrCheckForNewItems.Enabled = true;
            this.tmrCheckForNewItems.Interval = 10000;
            this.tmrCheckForNewItems.Tick += new System.EventHandler(this.tmrCheckForNewItems_Tick);
<span style='color:green'>            // </span>
<span style='color:green'>            // deleteAllToolStripMenuItem</span>
<span style='color:green'>            // </span>
            this.deleteAllToolStripMenuItem.Name = "deleteAllToolStripMenuItem";
            this.deleteAllToolStripMenuItem.Size = new System.Drawing.Size(176, 34);
            this.deleteAllToolStripMenuItem.Text = "Delete All";
            this.deleteAllToolStripMenuItem.Click += new System.EventHandler(this.deleteAllToolStripMenuItem_Click_1);
<span style='color:green'>            // </span>
<span style='color:green'>            // frmMain</span>
<span style='color:green'>            // </span>
            this.AutoScaleDimensions = new System.Drawing.SizeF(12F, 30F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(568, 602);
            this.Controls.Add(this.splitContainer1);
            this.Controls.Add(this.staMain);
            this.Controls.Add(this.menuStrip1);
            this.Font = new System.Drawing.Font("Segoe UI", 15.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.Margin = new System.Windows.Forms.Padding(6, 7, 6, 7);
            this.Name = "frmMain";
            this.Text = "RSS News Reader";
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.frmMain_FormClosed);
            this.Load += new System.EventHandler(this.frmMain_Load);
            this.menuStrip1.ResumeLayout(false);
            this.menuStrip1.PerformLayout();
            this.staMain.ResumeLayout(false);
            this.staMain.PerformLayout();
            this.splitContainer1.Panel1.ResumeLayout(false);
            this.splitContainer1.Panel2.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).EndInit();
            this.splitContainer1.ResumeLayout(false);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.MenuStrip menuStrip1;
        private System.Windows.Forms.ToolStripMenuItem mnuFile;
        private System.Windows.Forms.ToolStripMenuItem mnuFileExit;
        private System.Windows.Forms.ToolStripMenuItem mnuHelp;
        private System.Windows.Forms.ToolStripMenuItem mnuHelpManual;
        private System.Windows.Forms.ToolStripMenuItem mnuHelpAbout;
        private System.Windows.Forms.StatusStrip staMain;
        private System.Windows.Forms.ToolStripStatusLabel lblStatus;
        private System.Windows.Forms.SplitContainer splitContainer1;
        private System.Windows.Forms.ListBox lstFeeds;
        private System.Windows.Forms.ListBox lstItems;
        private System.Windows.Forms.ToolStripMenuItem mnuFileImport;
        private System.Windows.Forms.ToolStripMenuItem mnuFileExport;
        private System.Windows.Forms.ToolStripMenuItem mnuFeeds;
        private System.Windows.Forms.ToolStripMenuItem refreshToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem mnuFeedsNext;
        private System.Windows.Forms.ToolStripMenuItem mnuFeedsPrevious;
        private System.Windows.Forms.ToolStripSeparator toolStripMenuItem1;
        private System.Windows.Forms.ToolStripMenuItem mnuWebsiteAdd;
        private System.Windows.Forms.ToolStripMenuItem deleteFeedToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem openFeedWebsiteToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem itemsToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem deleteToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem viewToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem deletedItemsToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripMenuItem2;
        private System.Windows.Forms.ToolStripMenuItem mnuFeedsDeleteallwebsitefeeds;
        private System.Windows.Forms.ToolStripMenuItem renameFeedToolStripMenuItem;
        private System.Windows.Forms.Timer tmrCheckForNewItems;
        private System.Windows.Forms.ToolStripMenuItem openFeedURlToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem deleteAllToolStripMenuItem;
    }
}

</pre>
</div>
<div class='csfile'>
<h2 id='ListBoxSounds.cs'>ListBoxSounds.cs</h2>
<pre>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RSSNewsReader
{
<span style='color:green'>    /// &lt;summary></span>
<span style='color:green'>    /// Provides ways to add accessible sounds to listboxes.</span>
<span style='color:green'>    /// Requires Microsoft.VisualBasic references.</span>
<span style='color:green'>    /// &lt;/summary></span>
    class ListBoxSounds
    {
        public static void AddSounds(System.Windows.Forms.Form f)
        {
            foreach (System.Windows.Forms.Control c in f.Controls)
            {
                if (c.GetType().ToString() == "ListBox")
                {
                    c.KeyUp += new System.Windows.Forms.KeyEventHandler(c_KeyUp);
                }
            }
        }

        static void c_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == System.Windows.Forms.Keys.Up)
            {
                if (((System.Windows.Forms.ListBox)sender).SelectedIndex == 0)
                {
                    Microsoft.VisualBasic.Interaction.Beep();
                }
            }
            else if (e.KeyCode == System.Windows.Forms.Keys.Down)
            {
                System.Windows.Forms.ListBox lb = (System.Windows.Forms.ListBox)sender;
                if (lb.SelectedIndex == lb.Items.Count - 1 || lb.Items.Count == 0)
                {
                    Microsoft.VisualBasic.Interaction.Beep();
                }
            }
        }
    }
}
</pre>
</div>
<div class='csfile'>
<h2 id='modI18N.cs'>modI18N.cs</h2>
<pre>
<span style='color:green'>/// &lt;summary></span>
<span style='color:green'>/// Contains I18Nisation code. C# equivalent of modI18N.vb in WebbIE4</span>
<span style='color:green'>/// Updated 27 Jan 2013</span>
<span style='color:green'>/// Updated 4 Feb 2013 to remove "contents" node from XML file.</span>
<span style='color:green'>/// &lt;/summary></span>
class I18N
{
    private System.Xml.XmlDocument _applicationXML;
    private string _languageCode;
    private bool _initialised;
    private bool _applicationXMLFound = false;
    private System.Xml.XmlDocument _commonXML;
    private bool _commonXMLFound = false;

    private bool _debug = false;
    
<span style='color:green'>    //So for general string use we need a simple "GetText()" function that returns either (1) the translation or</span>
<span style='color:green'>    //(2) the original, which should be English so the code is readable.</span>
<span style='color:green'>    //   Is it in Application translations?</span>
<span style='color:green'>    //   If not, is it in Common translations?</span>
<span style='color:green'>    //   If not found, return original string.</span>
<span style='color:green'>    //For translating forms we need to do each control. </span>
<span style='color:green'>    //FIRST for the .Text property:</span>
<span style='color:green'>    //   1 Is it one of the controls where we don't translate the .Text property? If yes, stop.</span>
<span style='color:green'>    //   2 Does it have a .Text property? Yes:</span>
<span style='color:green'>    //       3 If it has a tag, try tag.Text in the Application translations</span>
<span style='color:green'>    //       4 If this is not found, or there is no tag, try formName.controlName.Text in the Application translations</span>
<span style='color:green'>    //       5 If this is not found, then try controlName.Text in Common translations</span>
<span style='color:green'>    //       6 If this is not found, then leave the control unchanged (should stay in English)</span>
<span style='color:green'>    //SECOND for the .AccessibleName property:</span>
<span style='color:green'>    //   1 Does it have an .AccessibleName property? If no, stop.</span>
<span style='color:green'>    //   2 Is the .AccessibleName property ""? If yes, stop.</span>
<span style='color:green'>    //   3 Try formName.controlName.AccessibleName in the Application translations</span>
<span style='color:green'>    //   4 If this is not found, then leave the control unchanged. </span>

<span style='color:green'>    //Use cases</span>
<span style='color:green'>    //   A simple string.</span>
<span style='color:green'>    //   A string containing quotation marks (get converted to single quotation marks)</span>
<span style='color:green'>    //   A string containing an ampersand.</span>
<span style='color:green'>    //   A control that has a .Text property but is not converted (ComboBox)</span>
<span style='color:green'>    //   A control that is set to not convert (WebBrowser) </span>
<span style='color:green'>    //   A control that has an AccessibleName in addition to a .Text property and not being converted.</span>
<span style='color:green'>    //   A control that has a tag.</span>
<span style='color:green'>    //   A control that is not in the application language file but the common language file.</span>


    public void SetDebug()
    {
        _initialised = false;
        Initialise();
        _languageCode = "xx";
        _debug = true;
    }

    private void WriteDebug(string s)
    {
        System.IO.StreamWriter sw = new System.IO.StreamWriter(System.Environment.GetFolderPath(System.Environment.SpecialFolder.DesktopDirectory) + "\\I18N Log.log", true, System.Text.Encoding.UTF8);
        sw.WriteLine(s);
        sw.Close();
        System.Windows.Forms.Application.DoEvents();
    }

    private void Initialise()
    {
        if (_initialised)
        {
<span style='color:green'>            //Already loaded.</span>
        }
        else
        {
<span style='color:green'>            //Load language-specific file.</span>
            _applicationXML = new System.Xml.XmlDocument();
            string applicationLanguagePath = System.Windows.Forms.Application.ExecutablePath;
            applicationLanguagePath = System.IO.Path.GetDirectoryName(applicationLanguagePath) + "\\" + System.IO.Path.GetFileNameWithoutExtension(applicationLanguagePath);
            applicationLanguagePath = applicationLanguagePath + ".Language.xml";
            if (System.IO.File.Exists(applicationLanguagePath))
            {
                try
                {
                    _applicationXML.Load(applicationLanguagePath);
                    _applicationXMLFound = true;
                }
                catch (System.Exception e)
                {
                    throw new System.Exception("Error loading the application language XML file, which was determined to be \"" + applicationLanguagePath + "\" The error returned was \"" + e.Message + "\"");
                }
            }
            else
            {
<span style='color:green'>                //No language file!</span>
                _applicationXMLFound = false;
                
            }

<span style='color:green'>            //Load common file.</span>
            _commonXML = new System.Xml.XmlDocument();
            string commonLanguagePath = System.Windows.Forms.Application.StartupPath + "\\Common.Language.xml";
            if (System.IO.File.Exists(commonLanguagePath))
            {
                try
                {
                    _commonXML.Load(commonLanguagePath);
                    _commonXMLFound = true;
                }
                catch (System.Exception e)
                {
                    throw new System.Exception("Error loading the application language XML file, which was determined to be \"" + applicationLanguagePath + "\" The error returned was \"" + e.Message + "\"");
                }
            }
            else
            {
<span style='color:green'>                //No common language file!</span>
                _commonXMLFound = false;
            }

<span style='color:green'>            //Load the locale information.</span>
            try
            {
                System.Globalization.CultureInfo ci = new System.Globalization.CultureInfo(System.Globalization.CultureInfo.CurrentUICulture.LCID);
<span style='color:green'>                // Thread.CurrentThread.CurrentCulture.LCID);</span>
                _languageCode = ci.TwoLetterISOLanguageName.ToLowerInvariant();
<span style='color:green'>                //en or pt or fr or whatever.</span>
            }
            catch
            {
                _languageCode = "en";
            }
            _initialised = true;
        }
    }

    public string GetLanguage()
    {
        Initialise();
        return _languageCode;
    }

    public void ShowHelp()
    {
        string pathBase = System.Windows.Forms.Application.ExecutablePath;
        pathBase = System.IO.Path.GetDirectoryName(pathBase) + "\\" + System.IO.Path.GetFileNameWithoutExtension(pathBase);
        string path = pathBase + ".Help-" + _languageCode + ".rtf";
        if (!System.IO.File.Exists(path))
        {
            if (_debug)
                WriteDebug("Did not find help file: " + path);
            path = pathBase + ".Help-en.rtf";
        }
        if (System.IO.File.Exists(path))
        {
            Microsoft.VisualBasic.Interaction.Shell("write \"" + path + "\"", Microsoft.VisualBasic.AppWinStyle.NormalFocus);
        }
    }

    public void DoForm(System.Windows.Forms.Form f)
    {
        Initialise();
        string name = f.Name;
        f.Text = GetText(name + ".Text");
        foreach (System.Windows.Forms.Control c in f.Controls)
        {
            DoControl(c, f.Name);
        }
    }

<span style='color:green'>    /// &lt;summary></span>
<span style='color:green'>    /// DoControl translates a control AND its children - usually the .Text value,</span>
<span style='color:green'>    /// but the .AccessibleName if there is one.</span>
<span style='color:green'>    /// &lt;/summary></span>
<span style='color:green'>    /// &lt;param name="c">&lt;/param></span>
<span style='color:green'>    /// &lt;param name="formName">&lt;/param></span>
<span style='color:green'>    /// &lt;remarks>&lt;/remarks></span>
    private void DoControl(System.Windows.Forms.Control c, string formName)
    {
<span style='color:green'>        //Handle .Text property</span>
        DoControlText(c, formName);

<span style='color:green'>        //Handle .AccessibleName property</span>
        DoControlAccessibleName(c, formName);

<span style='color:green'>        // Handle ToolStrip control - includes menus like the File menu. </span>
        if ((c) is System.Windows.Forms.ToolStrip)
        {
<span style='color:green'>            //Tool strip. Need to process items.</span>
            foreach (System.Windows.Forms.ToolStripItem ti in ((System.Windows.Forms.ToolStrip)c).Items)
            {
                DoControlItem(ti, formName);
            }
        }

<span style='color:green'>        //This child iteration handles things like Panel controls hosting TextBox </span>
<span style='color:green'>        //controls. It doesn't handle things like ToolstripMenuItem controls in MenuStrips. See the </span>
<span style='color:green'>        //code above for that.</span>
        if (c.HasChildren)
        {
            foreach (System.Windows.Forms.Control cChild in c.Controls)
            {
                DoControl(cChild, formName);
            }
        }
    }

    private void DoControlText(System.Windows.Forms.Control c, string formName)
    {
        bool doText = false;
<span style='color:green'>        //Some controls we do not look up: notably TextBox</span>
        if ((c) is System.Windows.Forms.TextBox)
        {
            doText = false;
        }
        else if ((c) is System.Windows.Forms.RichTextBox)
        {
            doText = false;
        }
        else if ((c) is System.Windows.Forms.ComboBox)
        {
            doText = false;
        }
        else if ((c) is System.Windows.Forms.ListBox)
        {
            doText = false;
        }
        else if ((c) is System.Windows.Forms.MenuStrip)
        {
            doText = false;
        }
        else if ((c) is System.Windows.Forms.WebBrowser)
        {
            doText = false;
        }
        else if ((c) is System.Windows.Forms.ToolStrip)
        {
            doText = false;
        }
        else if ((c) is System.Windows.Forms.Panel)
        {
            doText = false;
        }
        else if ((c) is System.Windows.Forms.PictureBox)
        {
            doText = false;
        }
        else if ((c) is System.Windows.Forms.StatusBar)
        {
            doText = false;
        }
        else if ((c.Text == null))
        {
            doText = false;
        }
        else
        {
            doText = true;
        }
        if (doText)
        {
            bool useTag = false;
            if (c.Tag == null)
            {
                useTag = false;
            }
            else if (string.IsNullOrEmpty(c.Tag.ToString()))
            {
                useTag = false;
            }
            else
            {
                useTag = true;
            }
            string key = null;
            if (useTag)
            {
                key = c.Tag.ToString();
            }
            else
            {
                key = formName + "." + c.Name;
            }

            string textKey = key + ".Text";
            string text = GetText(textKey);
            if (text != textKey)
            {
<span style='color:green'>                //Found an entry.</span>
                c.Text = text;
            }
            else
            {
<span style='color:green'>                //Failed to find anything when using the tag or the full formName.controlName</span>
<span style='color:green'>                //Try falling back now to our Common file, which should save me having to </span>
<span style='color:green'>                //duplicate lots and lots of entries.</span>
                textKey = c.Name + ".Text";
                text = GetText(textKey);
                if (text != textKey)
                {
                    c.Text = text;
                }
            }
        }
    }

    private void DoControlAccessibleName(System.Windows.Forms.Control c, string formName)
    {
        if (c.AccessibleName == null)
        {
        }
        else if (c.AccessibleName.Length == 0)
        {
        }
        else
        {
            string key = formName + "." + c.Name;
            string accKey = key + ".AccessibleName";
            string accName = GetText(accKey);
            if (accName != accKey)
            {
                c.AccessibleName = accName;
            }
        }
    }

    private void DoControlItem(System.Windows.Forms.ToolStripItem mi, string formName)
    {
<span style='color:green'>        //Notice no .tag support. That's because in WebbIE there are lots of bookmark menu items</span>
<span style='color:green'>        //that have url tags. Don't want to I18N them. So skip tags for menus for now.</span>
        string key = null;
        bool doText = true;
        if (mi.Name.Length == 0)
        {
<span style='color:green'>            //No name: like, a menu element that is a divider, or empty - like the favorites in </span>
<span style='color:green'>            //the WebbIE favorites menu.</span>
            key = "";
            doText = false;
        }
        else
        {
            key = formName + "." + mi.Name;
        }
        if (doText)
        {
            string textKey = key + ".Text";
            string text = GetText(textKey);
            if (text != textKey)
            {
                mi.Text = text;
            }
            else
            {
<span style='color:green'>                //Failed to find anything when using the tag or the full formName.controlName</span>
<span style='color:green'>                //Try falling back now to our Common file, which should save me having to </span>
<span style='color:green'>                //duplicate lots and lots of entries.</span>
                textKey = mi.Name + ".Text";
                text = GetText(textKey);
                if (text != textKey)
                {
                    mi.Text = text;
                }
            }
        }
<span style='color:green'>        //Now do drop-down items.</span>
        if ((mi) is System.Windows.Forms.ToolStripMenuItem & !((mi) is System.Windows.Forms.ToolStripSeparator))
        {
            foreach (object miChild in ((System.Windows.Forms.ToolStripMenuItem)mi).DropDownItems)
            {
                if ((miChild) is System.Windows.Forms.ToolStripSeparator)
                {
                }
                else
                {
                    DoControlItem((System.Windows.Forms.ToolStripMenuItem)miChild, formName);
                }
            }
        }
    }

<span style='color:green'>    /// &lt;summary></span>
<span style='color:green'>    /// Returns the internationalised version of the string provided according to the current</span>
<span style='color:green'>    /// language (and the availability of the translation.)</span>
<span style='color:green'>    /// &lt;/summary></span>
<span style='color:green'>    /// &lt;param name="text">&lt;/param></span>
<span style='color:green'>    /// &lt;returns>&lt;/returns></span>
<span style='color:green'>    /// &lt;remarks></span>
<span style='color:green'>    /// If there is no "item" node in AssemblyName.Language.xml that has a "key" node</span>
<span style='color:green'>    /// containing the argument text then the argument text is returned. This means that</span>
<span style='color:green'>    /// if the code calls GetText("Hello world") and no translation is provided then then</span>
<span style='color:green'>    /// function will return "Hello world". On the assumption that calling code is English</span>
<span style='color:green'>    /// there is therefore an implicit English default.</span>
<span style='color:green'>    /// If the "item" node that matches the argument text has a "leaveBlank" child then</span>
<span style='color:green'>    /// the empty string is returned.</span>
<span style='color:green'>    /// &lt;/remarks></span>
    public string GetText(string text)
    {
        Initialise();
        string key = null;
        key = text.Replace("\"", "'");
        System.Xml.XmlNode n = null;
        if (_applicationXMLFound)
        {
            n = _applicationXML.DocumentElement.SelectSingleNode("item[key=\"" + key + "\"]");
        }
        if (n == null)
        {
<span style='color:green'>            //Nothing found in the application translation file: try our common language file.</span>
            if (_commonXMLFound)
            {
                n = _commonXML.DocumentElement.SelectSingleNode("item[key=\"" + key + "\"]");
            }
            if (n == null)
            {
                if (_debug)
                {
                    WriteDebug("&lt;item>&lt;key>" + key + "&lt;/key>&lt;content language=\"en\">" + text + "&lt;/content>&lt;content language=\"xx\">Xxxxx&lt;/content>&lt;/item>");
                }
                return text;
            }
            else
            {
                System.Xml.XmlNode item = n.SelectSingleNode("content[@language=\"" + _languageCode + "\"]");
                if (item == null)
                {
                    return text;
                }
                else
                {
                    return item.InnerText;
                }
            }
        }
        else
        {
            if (n.SelectSingleNode("leaveBlank") == null)
            {
                System.Xml.XmlNode item = n.SelectSingleNode("content[@language=\"" + _languageCode + "\"]");
                if (item == null)
                {
                    return text;
                }
                else
                {
                    return item.InnerText;
                }
            }
            else
            {
                return "";
            }
        }
    }

} // end of class
</pre>
</div>
<div class='csfile'>
<h2 id='Program.cs'>Program.cs</h2>
<pre>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace RSSNewsReader
{
    static class Program
    {
<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// The main entry point for the application.</span>
<span style='color:green'>        /// &lt;/summary></span>
        [STAThread]
        [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags = System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain)]
        static void Main()
        {
<span style='color:green'>            // Add the event handler for handling UI thread exceptions to the event.</span>
            Application.ThreadException += new System.Threading.ThreadExceptionEventHandler(UIThreadException);
<span style='color:green'>            // Set the unhandled exception mode to force all Windows Forms errors to go through</span>
<span style='color:green'>            // our handler.</span>
            Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException);

<span style='color:green'>            // Upgrade settings from previous installed versions.</span>
            UpgradeSettings();

            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new frmMain());
        }

        private static void UIThreadException(object sender, System.Threading.ThreadExceptionEventArgs e)
        {
            try
            {
                if (!System.Diagnostics.EventLog.SourceExists(Application.ProductName))
                {
                    System.Diagnostics.EventLog.CreateEventSource(Application.ProductName, Application.ProductName);
                }

                System.Diagnostics.EventLog.WriteEntry(Application.ProductName, e.Exception.Message + "\r\n" + e.Exception.Source, System.Diagnostics.EventLogEntryType.Error, 1000);
            }
            catch
            {
            }
        }

        private static void CurrentDomain_UnhandledException(object sender, System.UnhandledExceptionEventArgs e)
        {
<span style='color:green'>            // Doesn't matter what you do, the application will terminate.</span>
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// UpgradeSettings. This function migrates your application's settings from the previous</span>
<span style='color:green'>        /// version, if any, to this one. This is because Properties.Settings are saved to a </span>
<span style='color:green'>        /// different user folder with every version, so unless you explicitly call this function</span>
<span style='color:green'>        /// then user settings will be lost with every upgrade.</span>
<span style='color:green'>        /// You must create a String setting called "LastVersionRun"</span>
<span style='color:green'>        /// Alasdair 11 June 2013</span>
<span style='color:green'>        /// &lt;/summary></span>
        public static void UpgradeSettings()
        {
            try
            {
                if (Properties.Settings.Default.LastVersionRun != Application.ProductVersion)
                {
                    Properties.Settings.Default.Upgrade();
                    Properties.Settings.Default.Reload();
                    Properties.Settings.Default.LastVersionRun = Application.ProductVersion;
                    Properties.Settings.Default.Save();
                }
            }
            catch
            {
<span style='color:green'>                //MessageBox.Show("Error in UpgradeSettings. Have you created a property called \"LastVersionRun\"?");</span>
            }
        }
<span style='color:green'>        // End of UpgradeSettings()</span>

    }
}
</pre>
</div>
<div class='csfile'>
<h2 id='Properties\AssemblyInfo.cs'>Properties\AssemblyInfo.cs</h2>
<pre>
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

<span style='color:green'>// General Information about an assembly is controlled through the following </span>
<span style='color:green'>// set of attributes. Change these attribute values to modify the information</span>
<span style='color:green'>// associated with an assembly.</span>
[assembly: AssemblyTitle("RSS News Reader")]
[assembly: AssemblyDescription("An RSS news reader that works with any screenreader")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Alasdair King")]
[assembly: AssemblyProduct("RSS News Reader")]
[assembly: AssemblyCopyright("Copyright © Alasdair King 2013")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

<span style='color:green'>// Setting ComVisible to false makes the types in this assembly not visible </span>
<span style='color:green'>// to COM components.  If you need to access a type in this assembly from </span>
<span style='color:green'>// COM, set the ComVisible attribute to true on that type.</span>
[assembly: ComVisible(false)]

<span style='color:green'>// The following GUID is for the ID of the typelib if this project is exposed to COM</span>
[assembly: Guid("f888b9aa-a6a3-4764-9aa4-90b9fce5ff0f")]

<span style='color:green'>// Version information for an assembly consists of the following four values:</span>
<span style='color:green'>//</span>
<span style='color:green'>//      Major Version</span>
<span style='color:green'>//      Minor Version </span>
<span style='color:green'>//      Build Number</span>
<span style='color:green'>//      Revision</span>
<span style='color:green'>//</span>
<span style='color:green'>// You can specify all the values or you can default the Build and Revision Numbers </span>
<span style='color:green'>// by using the '*' as shown below:</span>
<span style='color:green'>// [assembly: AssemblyVersion("1.0.*")]</span>
[assembly: AssemblyVersion("3.1.1.1")]
[assembly: AssemblyFileVersion("3.1.1.1")]
</pre>
</div>
<div class='csfile'>
<h2 id='ReadDatabase.cs'>ReadDatabase.cs</h2>
<pre>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RSSNewsReader
{
    public class ReadDatabase
    {
        System.Collections.ArrayList _read;
        string _AppPath;

        public ReadDatabase(string userDataPath)
        {
            _AppPath = userDataPath;
            _read = new System.Collections.ArrayList();
            if (System.IO.File.Exists(_AppPath + "\\read.txt"))
            {
                System.IO.StreamReader sr = new System.IO.StreamReader(_AppPath + "\\read.txt", Encoding.UTF8);
                while (!sr.EndOfStream)
                {
                    string readEntry = sr.ReadLine().Trim();
                    if (readEntry.Length > 0)
                    {
                        _read.Add(readEntry);
                    }
                }
                sr.Close();
            }
        }


<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Call this before terminating the class to save the database to disk.</span>
<span style='color:green'>        /// &lt;/summary></span>
        public void Save()
        {
            System.IO.StreamWriter sw = new System.IO.StreamWriter(_AppPath + "\\read.txt", false, Encoding.UTF8);
            for (int i = 0; i &lt; _read.Count; i++)
            {
                sw.WriteLine(_read[i]);
            }
            sw.Close();
        }

        public bool IsRead(RSSItem itemNode)
        {
<span style='color:green'>            //System.Diagnostics.Debug.Print("CHECKING IF READ:" + itemNode.Url);</span>
            string id = itemNode.feedUrl + "*" + itemNode.Url;
            for (int i = 0; i &lt; _read.Count; i++)
            {
                if ((string)this._read[i] == id)
                {
                    return true;
                }
            }
            return false;
        }

        public void ClearAll()
        {
            _read = new System.Collections.ArrayList();
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Call this when you are deleting a feed from your collection: it will</span>
<span style='color:green'>        /// remove the read/unread information for the feed. </span>
<span style='color:green'>        /// &lt;/summary></span>
<span style='color:green'>        /// &lt;param name="feed">&lt;/param></span>
        public void RemoveFeed(string url)
        {
            for (int i = _read.Count - 1; i >= 0; i--)
            {
                if (_read[i].ToString().StartsWith(url))
                {
                    _read.RemoveAt(i);
                }
            }
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Call this before you clear the list or exit the program to save read.</span>
<span style='color:green'>        /// &lt;/summary></span>
<span style='color:green'>        /// &lt;param name="items">&lt;/param></span>
<span style='color:green'>        /// &lt;param name="feedUrl">&lt;/param></span>
        public void WriteItems(RSSFeed feed)
        {
            if (feed == null)
                return;
            else if (feed.Items.Count == 0)
                return;
            System.Collections.ArrayList itemIds = new System.Collections.ArrayList();
            foreach (RSSItem item in feed.Items)
            {
                string id = feed.url + "*" + item.Url;
                itemIds.Add(id);
                if (item.IsRead)
                {
<span style='color:green'>                    // Add to _read array.</span>
                    bool found = false;
                    for (int i = 0; i &lt; _read.Count; i++)
                    {
                        if ((string)_read[i] == id)
                        {
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                    {
                        _read.Add(id);
                        System.Diagnostics.Debug.Print("READ:" + id);
                    }
                }
            }
<span style='color:green'>            // Now clean up the _read array, removing items that are no longer items</span>
<span style='color:green'>            // in the feed.</span>
            for (int i = _read.Count - 1; i > -1; i--)
            {
                string savedId = _read[i].ToString();
                if (savedId.StartsWith(feed.url))
                {
<span style='color:green'>                    // Item from this feed. Is it still an item?</span>
                    bool stillItem = false;
                    for (int j = 0; j &lt; itemIds.Count; j++)
                    {
                        System.Diagnostics.Debug.Print("CHECK:" + (string)itemIds[j]);
                        if (savedId == (string)itemIds[j])
                        {
<span style='color:green'>                            // Yes.</span>
                            stillItem = true;
                            break;
                        }
                    }
                    if (!stillItem)
                    {
                        System.Diagnostics.Debug.Print("DELETING:" + savedId);
                        _read.RemoveAt(i);
                    }
                }
            }
        }
    }
}
</pre>
</div>
<div class='csfile'>
<h2 id='RSSFeed.cs'>RSSFeed.cs</h2>
<pre>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RSSNewsReader
{
<span style='color:green'>    /// &lt;summary></span>
<span style='color:green'>    /// One loaded RSS Feed</span>
<span style='color:green'>    /// &lt;/summary></span>
    public class RSSFeed
    {
        string _url;
        System.Collections.ArrayList _items;

        public RSSFeed(string url)
        {
            _url = url;
            _items = new System.Collections.ArrayList();
        }

        public void AddItem(RSSItem item)
        {
            _items.Add(item);
        }

        public System.Collections.ArrayList Items
        {
            get
            {
                return this._items;
            }
        }

        public System.Collections.ArrayList UnreadItems
        {
            get
            {
                System.Collections.ArrayList al = new System.Collections.ArrayList();
                foreach (RSSItem item in this._items)
                {
                    if (!item.IsRead)
                    {
                        al.Add(item);
                    }
                }
                return al;
            }
        }

        public string url
        {
            get
            {
                return _url;
            }
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Marks the identified Item as read.</span>
<span style='color:green'>        /// &lt;/summary></span>
<span style='color:green'>        /// &lt;param name="readItem">&lt;/param></span>
        public void MarkAsRead(RSSItem readItem)
        {
            foreach (RSSItem item in _items)
            {
                if (item.Url == readItem.Url)
                {
                    item.IsRead = true;
                    break;
                }
            }
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Mark all the items in this feed as read.</span>
<span style='color:green'>        /// &lt;/summary></span>
        public void MarkAllAsRead()
        {
            foreach (RSSItem item in _items)
            {
                item.IsRead = true;
            }
        }
        
<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// When loading an RSS Feed, call this after loading the items</span>
<span style='color:green'>        /// so each one is correctly marked read or not.</span>
<span style='color:green'>        /// &lt;/summary></span>
<span style='color:green'>        /// &lt;param name="rd">&lt;/param></span>
        public void IdentifyReadItems(ReadDatabase rd)
        {
            foreach (RSSItem item in _items)
            {
                item.IsRead = rd.IsRead(item);
            }
        }
    }

}
</pre>
</div>
<div class='csfile'>
<h2 id='RSSItem.cs'>RSSItem.cs</h2>
<pre>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RSSNewsReader
{
<span style='color:green'>    /// &lt;summary></span>
<span style='color:green'>    /// One item in an RSS feed</span>
<span style='color:green'>    /// &lt;/summary></span>
    public class RSSItem
    {
        private string _title;
        private string _feedUrl;
        private string _itemUrl;
        private bool _isRead;
        private string _pubDate;
        private string _contents;

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Whether RSS or Atom</span>
<span style='color:green'>        /// &lt;/summary></span>
        public enum RSSType
        {
<span style='color:green'>            /// &lt;summary></span>
<span style='color:green'>            /// This is an Atom feed</span>
<span style='color:green'>            /// &lt;/summary></span>
            Atom,
<span style='color:green'>            /// &lt;summary></span>
<span style='color:green'>            /// This is an RSS feed</span>
<span style='color:green'>            /// &lt;/summary></span>
            RSS
        }

        public RSSItem(string title, string itemUrl, string feedUrl, string pubDate, string contents)
        {
            _title = title;
<span style='color:green'>            // Do character substitutions to catch character escape sequences that have ended up in the data</span>
<span style='color:green'>            // probably because of an error on the website. I'm sure this list could be extended, but </span>
<span style='color:green'>            // quotation marks and dashes are the main offenders.</span>
            _title = clsLibrary.CleanUpXml(_title);
            _feedUrl = feedUrl;
            _itemUrl = itemUrl;
            DateTime dt;
            if (DateTime.TryParse(pubDate, out dt))
            {
                _pubDate = dt.ToLongDateString();
                if (_pubDate.StartsWith("0"))
                {
<span style='color:green'>                    // Leading zeros look sucky.</span>
                    _pubDate = _pubDate.Substring(1, _pubDate.Length - 1);
                }
            }
            else
            {
                _pubDate = "";
            }
            _contents = TrivialParse(contents);
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        /// Parse the HTML into text very stupidly.</span>
<span style='color:green'>        /// &lt;/summary></span>
<span style='color:green'>        /// &lt;param name="html">&lt;/param></span>
<span style='color:green'>        /// &lt;returns>&lt;/returns></span>
        private string TrivialParse(string html)
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder();
            Char[] htmlChars = html.ToCharArray();
            int parseState = 0; // 0 = output, 1 = don't output, 2 = don't output this character but output next.
            for (int i = 0; i &lt; htmlChars.Length; i++)
            {
                if (htmlChars[i] == '&lt;')
                {
                    parseState = 1;
                }
                else if (htmlChars[i] == '>')
                {
                    parseState = 2;
                }
                else if (parseState == 0)
                {
                    sb.Append(htmlChars[i]);
                }
                if (parseState == 2)
                {
                    sb.Append(" ");
                    parseState = 0;
                }
            }
            string output = sb.ToString();
            while (output.Contains("  "))
            {
                output = output.Replace("  ", " ");
            }
            return clsLibrary.CleanUpXml(output.Trim());
        }

        public string contents
        {
            get
            {
                return _contents;
            }
        }

        public string feedUrl
        {
            get
            {
                return _feedUrl;
            }
        }

        public override string ToString()
        {
            string name;
            if (_pubDate.Length == 0)
            {
                name = _title;
            }
            else
            {
                name = _title + " (" + _pubDate + ")";
            }
            if (_contents.Length == 0)
            {
                return name;
            }
            else if (_contents.Length > 640)
            {
                return name + " \"" + _contents.Substring(0, 640).Replace("\n", " ") + "...\"";
            }
            else
            {
                return name + " \"" + _contents.Replace("\n", " ") + "\"";
            }
        }


        public string Url
        {
            get
            {
                return _itemUrl;
            }
        }

        public bool IsRead
        {
            get
            {
                return _isRead;
            }
            set
            {
                _isRead = value;
            }
        }
    }
}
</pre>
</div>
<div class='csfile'>
<h2 id='Properties\Resources.Designer.cs'>Properties\Resources.Designer.cs</h2>
<pre>
<span style='color:green'>//------------------------------------------------------------------------------</span>
<span style='color:green'>// &lt;auto-generated></span>
<span style='color:green'>//     This code was generated by a tool.</span>
<span style='color:green'>//     Runtime Version:4.0.30319.18010</span>
<span style='color:green'>//</span>
<span style='color:green'>//     Changes to this file may cause incorrect behavior and will be lost if</span>
<span style='color:green'>//     the code is regenerated.</span>
<span style='color:green'>// &lt;/auto-generated></span>
<span style='color:green'>//------------------------------------------------------------------------------</span>

namespace RSSNewsReader.Properties
{


<span style='color:green'>    /// &lt;summary></span>
<span style='color:green'>    ///   A strongly-typed resource class, for looking up localized strings, etc.</span>
<span style='color:green'>    /// &lt;/summary></span>
<span style='color:green'>    // This class was auto-generated by the StronglyTypedResourceBuilder</span>
<span style='color:green'>    // class via a tool like ResGen or Visual Studio.</span>
<span style='color:green'>    // To add or remove a member, edit your .ResX file then rerun ResGen</span>
<span style='color:green'>    // with the /str option, or rebuild your VS project.</span>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        ///   Returns the cached ResourceManager instance used by this class.</span>
<span style='color:green'>        /// &lt;/summary></span>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("RSSNewsReader.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

<span style='color:green'>        /// &lt;summary></span>
<span style='color:green'>        ///   Overrides the current thread's CurrentUICulture property for all</span>
<span style='color:green'>        ///   resource lookups using this strongly typed resource class.</span>
<span style='color:green'>        /// &lt;/summary></span>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
</pre>
</div>
<div class='csfile'>
<h2 id='Properties\Settings.Designer.cs'>Properties\Settings.Designer.cs</h2>
<pre>
<span style='color:green'>//------------------------------------------------------------------------------</span>
<span style='color:green'>// &lt;auto-generated></span>
<span style='color:green'>//     This code was generated by a tool.</span>
<span style='color:green'>//     Runtime Version:4.0.30319.18046</span>
<span style='color:green'>//</span>
<span style='color:green'>//     Changes to this file may cause incorrect behavior and will be lost if</span>
<span style='color:green'>//     the code is regenerated.</span>
<span style='color:green'>// &lt;/auto-generated></span>
<span style='color:green'>//------------------------------------------------------------------------------</span>

namespace RSSNewsReader.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("0")]
        public int SelectedFeedIndex {
            get {
                return ((int)(this["SelectedFeedIndex"]));
            }
            set {
                this["SelectedFeedIndex"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("False")]
        public bool ViewDeletedItems {
            get {
                return ((bool)(this["ViewDeletedItems"]));
            }
            set {
                this["ViewDeletedItems"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("2000-01-01")]
        public global::System.DateTime ImportedPreviousVersionFeeds {
            get {
                return ((global::System.DateTime)(this["ImportedPreviousVersionFeeds"]));
            }
            set {
                this["ImportedPreviousVersionFeeds"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("")]
        public string LastVersionRun {
            get {
                return ((string)(this["LastVersionRun"]));
            }
            set {
                this["LastVersionRun"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("")]
        public string UpdateCheck {
            get {
                return ((string)(this["UpdateCheck"]));
            }
            set {
                this["UpdateCheck"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("Maximized")]
        public global::System.Windows.Forms.FormWindowState WindowState {
            get {
                return ((global::System.Windows.Forms.FormWindowState)(this["WindowState"]));
            }
            set {
                this["WindowState"] = value;
            }
        }
    }
}
</pre>
</div>
</body>
</html>
